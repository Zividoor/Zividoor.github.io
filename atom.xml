<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-28T08:19:05.015Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/08/28/hello-world/"/>
    <id>http://yoursite.com/2019/08/28/hello-world/</id>
    <published>2019-08-28T08:19:05.015Z</published>
    <updated>2019-08-28T08:19:05.015Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>消息中间件选型分析</title>
    <link href="http://yoursite.com/2019/05/20/JMS-3/"/>
    <id>http://yoursite.com/2019/05/20/JMS-3/</id>
    <published>2019-05-20T06:58:28.000Z</published>
    <updated>2019-08-28T08:13:34.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h3><p>公司正在进行新产品的开发，为了产品的拓展性和后期维护等各方面考虑，决定使用消息中间件来处理数据交互。<br>这里明确一些具体的需求： 利用消息中间件看能不能实现消息的同步，由于消息中间件本身就是异步的，所以这里的同步是只在一定时间差之内的准实时同步，我们可以理解为只是数据上的同步，简单来讲就是用消息中间件做数据非实时同步。其二，实现典型的pub/sub功能，就是实现消息分发。</p><h3 id="消息队列使用场景"><a href="#消息队列使用场景" class="headerlink" title="消息队列使用场景"></a>消息队列使用场景</h3><p><strong>异步通信</strong></p><p>有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><p><strong>解耦</strong></p><p>降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><p><strong>冗余</strong></p><p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p><p><strong>扩展性</strong></p><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容。</p><p><strong>过载保护</strong></p><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p><p><strong>可恢复性</strong></p><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p><p><strong>顺序保证</strong></p><p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。</p><p><strong>缓冲</strong></p><p>在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。</p><p><strong>数据流处理</strong></p><p>分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择。    </p><h3 id="各类消息队列简述"><a href="#各类消息队列简述" class="headerlink" title="各类消息队列简述"></a>各类消息队列简述</h3><p><em>ActiveMQ</em> 是 Apache 出品的、采用 Java 语言编写的完全基于 JMS1.1 规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。不过由于历史原因包袱太重，目前市场份额没有后面三种消息中间件多，其最新架构被命名为 Apollo，号称下一代 ActiveMQ，有兴趣的同学可行了解。</p><p><em>RabbitMQ</em> 是采用 Erlang 语言实现的 AMQP 协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。RabbitMQ 发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。</p><p><em>Kafka</em> 起初是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 zookeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。</p><p><em>RocketMQ</em> 是阿里开源的消息中间件，目前已经捐献个 Apache 基金会，它是由 Java 语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过双 11 的洗礼，实力不容小觑。</p><p><em>ZeroMQ</em> 号称史上最快的消息队列，基于 C 语言开发。ZeroMQ 是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩，虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ 本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的 Socket API 上加上一层封装而已。</p><h3 id="消息中间件功能维度"><a href="#消息中间件功能维度" class="headerlink" title="消息中间件功能维度"></a>消息中间件功能维度</h3><p>功能维度又可以划分个多个子维度，大致可以分为以下这些：</p><p><strong>优先级队列</strong></p><p>优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证。不过这个优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器（一般简单的称之为 Broker）中没有消息堆积，那么对于发送的消息设置优先级也就没有什么实质性的意义了，因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</p><p><strong>延迟队列</strong></p><p>当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”？这个是延迟队列的一种典型应用场景。延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。延迟队列一般分为两种：基于消息的延迟和基于队列的延迟。基于消息的延迟是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。实际应用中大多采用基于队列的延迟，设置不同延迟级别的队列，比如 5s、10s、30s、1min、5mins、10mins 等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略（比如定时）即可投递超时的消息。</p><p><strong>死信队列</strong></p><p>由于某些原因消息无法被正确的投递，为了确保消息不会被无故的丢弃，一般将其置于一个特殊角色的队列，这个队列一般称之为死信队列。与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认（Ack）, 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。</p><p><strong>重试队列</strong></p><p>重试队列其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。举个例子：消息第一次消费失败入重试队列 Q1，Q1 的重新投递延迟为 5s，在 5s 过后重新投递该消息；如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延迟为 10s，在 10s 过后再次投递该消息。以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列。重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发；延迟队列作用一次，而重试队列的作用范围会向后传递。</p><p><strong>消费模式</strong></p><p>消费模式分为推（push）模式和拉（pull）模式。推模式是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。而拉模式是指消费端主动向 Broker 端请求拉取（一般是定时或者定量）消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。</p><p><strong>广播消费</strong></p><p>消息一般有两种传递模式：点对点（P2P，Point-to-Point）模式和发布 / 订阅（Pub/Sub）模式。对于点对点的模式而言，消息被消费以后，队列中不会再存储，所以消息消费者不可能消费到已经被消费的消息。虽然队列可以支持多个消费者，但是一条消息只会被一个消费者消费。发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（topic），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布 / 订阅模式在消息的一对多广播时采用。RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式。但是 RabbitMQ 中可以通过设置交换器类型来实现发布订阅模式而达到广播消费的效果，Kafka 中也能以点对点的形式消费，你完全可以把其消费组（consumer group）的概念看成是队列的概念。不过对比来说，Kafka 中因为有了消息回溯功能的存在，对于广播消费的力度支持比 RabbitMQ 的要强。</p><p><strong>消息回溯</strong></p><p>一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息。消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失一般很难追查，如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头之所在。消息回溯的作用远不止与此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。</p><p><strong>消息堆积 + 持久化</strong></p><p>流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。消息堆积分内存式堆积和磁盘式堆积。RabbitMQ 是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘（换页动作会影响吞吐），或者直接使用惰性队列来将消息直接持久化至磁盘中。Kafka 是一种典型的磁盘式堆积，所有的消息都存储在磁盘中。一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。援引 纽约时报的案例，其直接将 Kafka 用作存储系统。</p><p><strong>消息追踪</strong></p><p>对于分布式架构系统中的链路追踪（trace）而言，大家一定不会陌生。对于消息中间件而言，消息的链路追踪（以下简称消息追踪）同样重要。对于消息追踪最通俗的理解就是要知道消息从哪来，存在哪里以及发往哪里去。基于此功能下，我们可以对发送或者消费完的消息进行链路追踪服务，进而可以进行问题的快速定位与排查。</p><p><strong>消息过滤</strong></p><p>消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。就以 kafka 而言，完全可以将不同类别的消息发送至不同的 topic 中，由此可以实现某种意义的消息过滤，或者 Kafka 还可以根据分区对同一个 topic 中的消息进行分类。不过更加严格意义上的消息过滤应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。同样以 Kafka 为例，可以通过客户端提供的 ConsumerInterceptor 接口或者 Kafka Stream 的 filter 功能进行消息过滤。</p><p><strong>多租户</strong></p><p>也可以称为多重租赁技术，是一种软件架构技术，主要用来实现多用户的环境下公用相同的系统或程序组件，并且仍可以确保各用户间数据的隔离性。RabbitMQ 就能够支持多租户技术，每一个租户表示为一个 vhost，其本质上是一个独立的小型 RabbitMQ 服务器，又有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。vhost 就像是物理机中的虚拟机一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地允许数据，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。</p><p><strong>多协议支持</strong></p><p>消息是信息的载体，为了让生产者和消费者都能理解所承载的信息（生产者需要知道如何构造消息，消费者需要知道如何解析消息），它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。有效的消息一定具有某种格式，而没有格式的消息是没有意义的。一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等（消息领域中的 JMS 更多的是一个规范而不是一个协议），支持的协议越多其应用范围就会越广，通用性越强，比如 RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地。还有的消息中间件是基于其本身的私有协议运转的，典型的如 Kafka。</p><p><strong>跨语言支持</strong></p><p>对很多公司而言，其技术栈体系中会有多种编程语言，如 C/C++、JAVA、Go、PHP 等，消息中间件本身具备应用解耦的特性，如果能够进一步的支持多客户端语言，那么就可以将此特性的效能扩大。跨语言的支持力度也可以从侧面反映出一个消息中间件的流行程度。</p><p><strong>流量控制</strong></p><p>流量控制（flow control）针对的是发送方和接收方速度不匹配的问题，提供一种速度匹配服务抑制发送速率使接收方应用程序的读取速率与之相适应。通常的流控方法有 Stop-and-wait、滑动窗口以及令牌桶等。</p><p><strong>消息顺序性</strong></p><p>顾名思义，消息顺序性是指保证消息有序。这个功能有个很常见的应用场景就是 CDC（Change Data Chapture），以 MySQL 为例，如果其传输的 binlog 的顺序出错，比如原本是先对一条数据加 1，然后再乘以 2，发送错序之后就变成了先乘以 2 后加 1 了，造成了数据不一致。</p><p><strong>安全机制</strong></p><p>在 Kafka 0.9 版本之后就开始增加了身份认证和权限控制两种安全机制。身份认证是指客户端与服务端连接进行身份认证，包括客户端与 Broker 之间、Broker 与 Broker 之间、Broker 与 ZooKeeper 之间的连接认证，目前支持 SSL、SASL 等认证机制。权限控制是指对客户端的读写操作进行权限控制，包括对消息或 Kafka 集群操作权限控制。权限控制是可插拔的，并支持与外部的授权服务进行集成。对于 RabbitMQ 而言，其同样提供身份认证（TLS/SSL、SASL）和权限控制（读写操作）的安全机制。</p><p><strong>消息幂等性</strong></p><p>对于确保消息在生产者和消费者之间进行传输而言一般有三种传输保障（delivery guarantee）：At most once，至多一次，消息可能丢失，但绝不会重复传输；At least once，至少一次，消息绝不会丢，但是可能会重复；Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。<br>Kafka 自 0.11 版本开始引入了幂等性和事务，Kafka 的幂等性是指单个生产者对于单分区单会话的幂等，而事务可以保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让 Kafka 具备 EOS（Exactly Once Semantic）的能力。<br>不过如果要考虑全局的幂等，还需要与从上下游方面综合考虑，即关联业务层面，幂等处理本身也是业务层面所需要考虑的重要议题。以下游消费者层面为例，有可能消费者消费完一条消息之后没有来得及确认消息就发生异常，等到恢复之后又得重新消费原来消费过的那条消息，那么这种类型的消息幂等是无法有消息中间件层面来保证的。如果要保证全局的幂等，需要引入更多的外部资源来保证，比如以订单号作为唯一性标识，并且在下游设置一个去重表。</p><p><strong>事务性消息</strong></p><p>事务本身是一个并不陌生的词汇，事务是由事务开始（Begin Transaction）和事务结束（End Transaction）之间执行的全体操作组成。支持事务的消息中间件并不在少数，Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败。消息中间件可以作为用来实现分布式事务的一种手段，但其本身并不提供全局分布式事务的功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景概述&quot;&gt;&lt;a href=&quot;#背景概述&quot; class=&quot;headerlink&quot; title=&quot;背景概述&quot;&gt;&lt;/a&gt;背景概述&lt;/h3&gt;&lt;p&gt;公司正在进行新产品的开发，为了产品的拓展性和后期维护等各方面考虑，决定使用消息中间件来处理数据交互。&lt;br&gt;这里明确一些具体
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux各个文件夹的作用</title>
    <link href="http://yoursite.com/2019/05/15/linux-1/"/>
    <id>http://yoursite.com/2019/05/15/linux-1/</id>
    <published>2019-05-15T08:41:45.000Z</published>
    <updated>2019-08-28T08:10:51.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="linux关于文件夹的基本信息"><a href="#linux关于文件夹的基本信息" class="headerlink" title="linux关于文件夹的基本信息"></a>linux关于文件夹的基本信息</h3><p><strong>各硬件设备在linux中的文件名称</strong><br>    在Linux系统中，每个装置都被当成一个档案来对待』举例来说，SATA介面的硬碟的档案名称即为/dev/sd[ad]，其中，括号内的字母为ad当中的任意一个，亦即有/dev/sda, /dev/sdb, /dev/sdc,及/dev/sdd这四个档案的意思。<br>常见设备在linux中的文件名：</p><table><tr style="background-color: lightblue; text-align: center"><td style="width: 200px">装置</td><td>装置在Linux内的档名</td></tr><tr class="text_import2"><td>SCSI/SATA/USB硬碟机</td><td>/dev/sd[ap]</td></tr><tr class="text_import2"><td>USB快闪碟</td><td>/dev/sd[ap] (与SATA相同)</td></tr><tr class="text_import2"><td>VirtI/O界面</td><td>/dev/vd[ap] (用于虚拟机器内)</td></tr><tr class="text_import2"><td>软碟机</td><td>/dev/fd[0-1]</td></tr><tr class="text_import2"><td>印表机</td><td>/dev/lp[0-2] (25针印表机) <br>/dev/usb/lp[0-15] (USB介面)</td></tr><tr class="text_import2"><td>滑鼠</td><td>/dev/input/mouse[0-15] (通用) <br>/dev/psaux (PS/2界面) <br>/dev/mouse (当前滑鼠)</td></tr><tr class="text_import2"><td>CDROM/DVDROM</td><td>/dev/scd[0-1] (通用) <br>/dev/sr[0-1] (通用，CentOS较常见) <br>/dev/cdrom (当前CDROM)</td></tr><tr class="text_import2"><td>磁带机</td><td>/dev/ht0 (IDE界面) <br>/dev/st0 (SATA/SCSI界面) <br>/dev/tape (当前磁带)</td></tr><tr class="text_import2"><td>IDE硬碟机</td><td>/dev/hd[ad] (旧式系统才有)</td></tr></table><p><strong>挂载</strong><br>   『挂载』就是利用一个目录当成进入点，将磁碟分割槽的资料放置在该目录下；也就是说，进入该目录就可以读取该分割槽的意思。</p><p><strong>/  根目录</strong><br>    包含了几乎所的文件目录。相当于中央系统。进入的最简单方法是：cd /。</p><p><strong>/boot  引导程序，内核等存放的目录</strong><br>    这个目录，包括了在引导过程中所必需的文件。在最开始的启动阶段，通过引导程序将内核加载到内存，完成内核的启动（这个时候，虚拟文件系统还不存在，加载的内核虽然是从硬盘读取的，但是没经过Linux的虚拟文件系统，这是比较底层的东西来实现的。然后内核自己创建好虚拟文件系统，并且从虚拟文件系统的其他子目录中（例如/sbin 和 /etc加载需要在开机启动的其他程序或者服务或者特定的动作（部分可以由用户自己在相应的目录中修改相应的文件来配制。如果我们的机器中包含多个操作系统，那么可以通过修改这个目录中的某个配置文件（例如grub.conf来调整启动的默认操作系统，系统启动的择菜单，以及启动延迟等参数。</p><p><strong>/sbin  超级用户可以使用的命令的存放目录</strong><br>    存放大多涉及系统管理的命令（例如引导系统的init程序，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令（但是有时普通用户也可能会用到。）我们要记住，凡是目录sbin中包含的都是root权限才能执行的。</p><p><strong>/bin  普通用户可以使用的命令的存放目录</strong><br>    系统所需要的那些命令位于此目录，比如ls、cp、mkdir等命令；类似的目录还/usr/bin，/usr/local/bin等等。这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里。</p><p><strong>/lib  根目录下的所程序的共享库目录</strong><br>    此目录下包含系统引导和在根用户执行命令时候所必需用到的共享库。做个不太好但是比较形象的比喻，点类似于Windows上面的system32目录。理说，这里存放的文件应该是/bin目录下程序所需要的库文件的存放地，也不排除一些例外的情况。类似的目录还/usr/lib，/usr/local/lib等等。</p><p><strong>/dev 设备文件目录</strong><br>    在Linux中设备都是以文件形式出现，这里的设备可以是硬盘，键盘，鼠标，网卡，终端，等设备，通过访问这些文件可以访问到相应的设备。设备文件可以使用mknod命令来创建；而为了将对这些设备文件的访问转化为对设备的访问，需要向相应的设备提供设备驱动模块（一般将设备驱动编译之后，生成的结果是一个*.ko类型的二进制文件，在内核启动之后，再通过insmod等命令加载相应的设备驱动之后，我们就可以通过设备文件来访问设备了。一般来说，想要Linux系统支持某个设备，需要 相应的硬件设备，支持硬件的驱动模块，以及相应的设备文件。</p><p><strong>/home  普通用户的家目录</strong><br>    在Linux机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。通常而言，系统的每个用户都自己的家目录，目录以用户名作为名字存放在/home下面（例如quietheart用户，其家目录的名字为/home/quietheart。该目录中保存了绝大多数的用户文件(用户自己的配置文件，定制文件，文档，数据等)，</p><p><strong>/root  用户root的$HOME目录</strong><br>    系统管理员(就是root用户或超级用户)的主目录比较特殊，不存放在/home中，而是直接放在/root目录下了。</p><p><strong>/etc 全局的配置文件存放目录。</strong><br>    系统和程序一般都可以通过修改相应的配置文件，来进行配置。例如，要配置系统开机的时候启动那些程序，配置某个程序启动的时候显示什么样的风格等等。通常这些配置文件都集中存放在/etc目录中，所以想要配置什么东西的话，可以在/etc下面寻找我们可能需要修改的文件。</p><ol><li><p>/etc/rc或/etc/rc.d或/etc/rc?.d<br>启动、或改变运行级时运行的脚本或脚本的目录。 </p></li><li><p>/etc/passwd<br>用户数据库，其中的域给出了用户名、真实姓名、用户起始目录、加密口令和用户的其他信息。 </p></li><li><p>/etc/fdprm<br>软盘参数表，用以说明不同的软盘格式。可用setfdprm 进行设置。更多的信息见setfdprm的帮助页。 </p></li><li><p>/etc/fstab<br>指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的s w a p区的信息。 </p></li><li><p>/etc/group<br>类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。 </p></li><li><p>/etc/inittab<br>init 的配置文件。 </p></li><li><p>/etc/issue<br>包括用户在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内容由系统管理员确定。 </p></li><li><p>/etc/magic<br>“file”的配置文件。包含不同文件格式的说明，“file”基于它猜测文件类型。 </p></li><li><p>/etc/motd<br>  motd是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等。 </p></li><li><p>/etc/mtab </p><p>当前安装的文件系统列表。由脚本(scritp)初始化，并由mount 命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如df 命令)。 </p></li><li><p>/etc/shadow </p><p>在安装了影子(shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd文件中的加密口令移动到/etc/shadow中，而后者只对超级用户(root)可读。这使破译口令更困难，以此增加系统的安全性。 </p></li><li><p>/etc/login.defs </p><p>login命令的配置文件。 </p></li><li><p>/etc/printcap </p><p>类似/etc/termcap ，但针对打印机。语法不同。 </p></li><li><p>/etc/profile/etc/csh.login、/etc/csh.cshrc </p><p>登录或启动时bourne或c shells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。 </p></li><li><p>/etc/securetty </p><p>确认安全终端，即哪个终端允许超级用户(root)登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器(modem)或网络闯入系统并得到超级用户特权。 </p></li><li><p>/etc/shells </p><p>列出可以使用的shell。chsh 命令允许用户在本文件指定范围内改变登录的shell。提供一台机器f t p服务的服务进程ftpd 检查用户s h e l l是否列在/etc/shells 文件中，如果不是，将不允许该用户登录。 </p></li><li><p>/etc/termcap </p><p>终端性能数据库。说明不同的终端用什么“转义序列”控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap 中查找要做的工作的正确序列。这样，多数的程序可以在多数终端上运行。</p></li></ol><p><strong>/usr  这个目录中包含了命令库文件和在通常操作中不会修改的文件。</strong><br>    这个目录对于系统来说也是一个非常重要的目录，其地位类似Windows上面的”Program Files”目录（安装程序的时候，默认就是安装在此文件内部某个子文件夹内。输入命令后系统默认执行/usr/bin下的程序（当然，前提是这个目录的路径已经被添加到了系统的环境变量中。此目录通常也会挂载一个独立的磁盘分区，它应保存共享只读类文件，这样它可以被运行Linux的不同主机挂载。</p><ol><li><p>/usr/lib<br>目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录，理说，这里存放的文件应该是/bin目录下程序所需要的库文件的存放地，也不排除一些例外的情况。</p></li><li><p>/usr/bin<br>一般使用者使用并且不是系统自检等所必需可执行文件的目录。此目录相当于根文件系统下的对应目录（/bin，非启动系统，非修复系统以及非本地安装的程序一般都放在此目录下。</p></li><li><p>/usr/sbin<br>管理员使用的非系统必须的可执行文件存放目录。<br>此目录相当于根文件系统下的对应目录（/sbin，保存系统管理程序的二进制文件，并且这些文件不是系统启动或文件系统挂载 /usr 目录或修复系统所必需的。</p></li><li><p>/usr/share<br>存放共享文件的目录。<br>在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据(例如程序文档信息)。使用者可以找到通常放在 /usr/doc 或 /usr/lib 或 /usr/man 目录下的这些类似数据。</p></li><li><p>/usr/include<br>C程序语言编译使用的头文件。<br>linux下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数。默认来说这个路径被添加到了环境变量中，这样编译开发程序的时候编译器会自动搜索这个路径，从中找到你的程序中可能包含的头文件。</p></li><li><p>/usr/local<br>安装本地程序的一般默认路径。<br>当我们下载一个程序源代码，编译并且安装的时候，如果不特别指定安装的程序路径，那么默认会将程序相关的文件安装到这个目录的对应目录下。也就是说，这个目录存放的内容，一般都是我们后来自己安装的软件的默认路径，如果择了这个默认路径作为软件的安装路径，被安装的软件的所文件都限制在这个目录中，其中的子目录就相应于根目录的子目录。</p></li></ol><p><strong>/proc  特殊文件目录</strong><br>    这个目录采用一种特殊的文件系统格式（proc格式，内核支持这种格式。其中包含了全部虚拟文件。它们并不保存在磁盘中，也不占据磁盘空间(尽管命令ls -c会显示它们的大小)。当您查看它们时，您实际上看到的是内存里的信息，这些文件助于我们了解系统内部信息。例如：</p><p>1/ 关于进程1的信息目录。每个进程在/proc 下一个名为其进程号的目录。<br>cpuinfo 处理器信息，如类型、制造商、型号和性能。<br>devices 当前运行的核心配置的设备驱动的列表。<br>dma 显示当前使用的DMA通道。<br>filesystems 核心配置的文件系统。<br>interrupts 显示使用的中断，and how many of each there have been.<br>ioports 当前使用的I/O端口。<br>kcore 系统物理内存映象。与物理内存大小一样，但实际不占这么多内存；<br>kmsg 核心输出的消息。也被送到syslog 。<br>ksyms 核心符号表。<br>loadavg 系统”平均负载”；3个没意义的指示器指出系统当前的工作量。<br>meminfo 存储器使用信息，包括物理内存和swap。<br>modules 当前加载了哪些核心模块。<br>net 网络协议状态信息。<br>self 到查看/proc 的程序的进程目录的符号连接。<br>stat 系统的不同状态<br>uptime 系统启动的时间长度。<br>version 核心版本。</p><p><strong>/opt  可择的文件目录</strong><br>    这个目录表示的是可择的意思，些自定义软件包或者第方工具，就可以安装在这里。</p><p><strong>/mnt  临时挂载目录</strong><br>    这个目录一般是用于存放挂载储存设备的挂载目录的，比如磁盘，光驱，网络文件系统等，当我们需要挂载某个磁盘设备的时候，可以把磁盘设备挂载到这个目录上去，这样我们可以直接通过访问这个目录来访问那个磁盘了。一般来说，我们最好在/mnt目录下面多建立几个子目录，挂载的时候挂载到这些子目录上面，因为通常我们可能不仅仅是挂载一个设备吧?</p><p><strong>/media  挂载的媒体设备目录</strong><br>    挂载的媒体设备目录，一般外部设备挂载到这里，例如cdrom等。比如我们插入一个U盘，我们一般会发现，Linux自动在这个目录下建立一个disk目录，然后把U盘挂载到这个disk目录上，通过访问这个disk来访问U盘。</p><p><strong>/var  内容经常变化的目录</strong><br>    此目录下文件的大小可能会改变，如缓冲文件，日志文件，缓存文件，等一般都存放在这里。</p><p><strong>/tmp  临时文件目录</strong><br>    该目录存放系统中的一些临时文件，文件可能会被系统自动清空。</p><p><strong>/lost+found   恢复文件存放的位置</strong><br>    当系统崩溃的时候，在系统修复过程中需要恢复的文件，可能就会在这里被找到了，这个目录一般为空。</p><p>另外，有些目录容易混淆，这里简单区分一下：<br>/bin,/sbin与/usr/bin,/usr/sbin:<br>/bin一般存放对于用户和系统来说“必须”的程序（二进制文件）。<br>/sbin一般存放用于系统管理的“必需”的程序（二进制文件），一般普通用户不会使用，根用户使用。<br>/usr/bin一般存放的只是对用户和系统来说“不是必需的”程序（二进制文件）。<br>/usr/sbin一般存放用于系统管理的系统管理的不是必需的程序（二进制文件）。</p><p>/lib与/usr/lib:<br>/lib和/usr/lib的区别类似/bin,/sbin与/usr/bin,/usr/sbin。<br>/lib一般存放对于用户和系统来说“必须”的库（二进制文件）。<br>/usr/lib一般存放的只是对用户和系统来说“不是必需的”库（二进制文件）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;linux关于文件夹的基本信息&quot;&gt;&lt;a href=&quot;#linux关于文件夹的基本信息&quot; class=&quot;headerlink&quot; title=&quot;linux关于文件夹的基本信息&quot;&gt;&lt;/a&gt;linux关于文件夹的基本信息&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;各硬件设备在linu
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 使用笔记</title>
    <link href="http://yoursite.com/2019/05/09/oracle-1/"/>
    <id>http://yoursite.com/2019/05/09/oracle-1/</id>
    <published>2019-05-09T06:41:41.000Z</published>
    <updated>2019-08-28T08:10:57.285Z</updated>
    
    <content type="html"><![CDATA[<h3 id="oracle中char-varchar-varchar2的区别"><a href="#oracle中char-varchar-varchar2的区别" class="headerlink" title="oracle中char,varchar,varchar2的区别"></a>oracle中char,varchar,varchar2的区别</h3><p>区别：<br>     1． CHAR的长度是固定的，而VARCHAR2的长度是可以变化的， 比如，存储字符串“abc”，对于CHAR (20)，表示你存储的字符将占20个字节(包括17个空字符)，而同样的VARCHAR2 (20)则只占用3个字节的长度，20只是最大值，当你存储的字符小于20时，按实际长度存储。<br>     2．CHAR的效率比VARCHAR2的效率稍高。<br>     3．目前VARCHAR是VARCHAR2的同义词。工业标准的VARCHAR类型可以存储空字符串，但是oracle不这样做，尽管它保留以后这样做的 权利。Oracle自己开发了一个数据类型VARCHAR2，这个类型不是一个标准的VARCHAR，它将在数据库中varchar列可以存储空字符串的 特性改为存储NULL值。如果你想有向后兼容的能力，Oracle建议使用VARCHAR2而不是VARCHAR。</p><p>何时该用CHAR，何时该用varchar2？<br>    CHAR与VARCHAR2是一对矛盾的统一体，两者是互补的关系.<br>    VARCHAR2比CHAR节省空间，在效率上比CHAR会稍微差一些，即要想获得效率，就必须牺牲一定的空间，这也就是我们在数据库设计上常说的‘以空间换效率’。<br>    VARCHAR2 虽然比CHAR节省空间，但是如果一个VARCHAR2列经常被修改，而且每次被修改的数据的长度不同，这会引起‘行迁移’(Row Migration)现象，而这造成多余的I/O，是数据库设计和调整中要尽力避免的，在这种情况下用CHAR代替VARCHAR2会更好一些。</p><pre><code>char中还会自动补齐空格，因为你insert到一个char字段自动补充了空格的,但是select 后空格没有删除。</code></pre><h3 id="新增表字段"><a href="#新增表字段" class="headerlink" title="新增表字段"></a>新增表字段</h3>{%codeblock%}comment  on  column  表名.字段名   is  '注释内容';{%endcodeblock%}<h3 id="表或字段添加注释"><a href="#表或字段添加注释" class="headerlink" title="表或字段添加注释"></a>表或字段添加注释</h3>{%codeblock%}comment on table 表名  is  '注释内容';{%endcodeblock%}<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3>{%codeblock%}CREATE INDEX 索引名 ON 表名 (列名) TABLESPACE 表空间名;{%endcodeblock%}<h3 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h3><p>本地的导出与导入:<br>    备份(也叫导出):</p>{%codeblock%}        exp用户名/密码@本地服务名  file = 目标地址{%endcodeblock%}<pre><code>(注:导出的文件是在硬盘上生成后缀名为dmp的文件)还原【导入】:</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">        imp 用户名/密码@本地服务名 file=文件的位置  ignore=y</span><br></pre></td></tr></table></figure><p>(注:ignore=y的作用是忽视一些不必要的错误,当然,不加也可以,但是小编向来都是那种眼不见心不乱的人,所以向来都是加上的)</p><p>远程的导出与导入:</p><pre><code>备份【导出】：</code></pre>{%codeblock%}        exp 用户名/密码@网络服务名 file=目标地址{%endcodeblock%}<pre><code>还原【导入】:</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">        imp 用户名/密码@网络服务名 file=文件位置  ignore=y</span><br></pre></td></tr></table></figure><p>(注意：如果从A用户导出，然后导入B用户，则需要加上 fromuser=A touser=B)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;oracle中char-varchar-varchar2的区别&quot;&gt;&lt;a href=&quot;#oracle中char-varchar-varchar2的区别&quot; class=&quot;headerlink&quot; title=&quot;oracle中char,varchar,varchar2的区
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringAOP中通过JoinPoint获取参数名和值</title>
    <link href="http://yoursite.com/2019/05/07/AOP-1/"/>
    <id>http://yoursite.com/2019/05/07/AOP-1/</id>
    <published>2019-05-07T08:10:27.000Z</published>
    <updated>2019-08-28T09:22:29.878Z</updated>
    
    <content type="html"><![CDATA[<p>在Java8之前，代码编译为class文件后，方法参数的类型固定，但是方法名称会丢失，方法名称会变成arg0、arg1….。在Java8开始可以在class文件中保留参数名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void tet(JoinPoint joinPoint) &#123;</span><br><span class="line">        // 下面两个数组中，参数值和参数名的个数和位置是一一对应的。</span><br><span class="line">        Object[] args = joinPoint.getArgs(); // 参数值</span><br><span class="line">        String[] argNames = ((MethodSignature)joinPoint.getSignature()).getParameterNames(); // 参数名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>IDEA中需要设置Java编译参数才能获取参数信息。且JDK版本需要在1.8及以上版本。<br><img src="/2019/05/07/AOP-1/1.png" alt="info"></p><p>Maven中开启编译参数方法<br>添加compilerArgs参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">     &lt;plugin&gt;</span><br><span class="line">         &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;$&#123;maven_compiler_plugin_version&#125;&lt;/version&gt;</span><br><span class="line">         &lt;configuration&gt;</span><br><span class="line">             &lt;source&gt;$&#123;java_source_version&#125;&lt;/source&gt;</span><br><span class="line">             &lt;target&gt;$&#123;java_target_version&#125;&lt;/target&gt;</span><br><span class="line">             &lt;encoding&gt;$&#123;file_encoding&#125;&lt;/encoding&gt;</span><br><span class="line">             &lt;compilerArgs&gt;</span><br><span class="line">                 &lt;arg&gt;-parameters&lt;/arg&gt;</span><br><span class="line">             &lt;/compilerArgs&gt;</span><br><span class="line">         &lt;/configuration&gt;</span><br><span class="line">     &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>Eclipse中开启方法<br>Preferences-&gt;java-&gt;Compiler下勾选Store information about method parameters选项。<br>这样在使用eclipse编译java文件的时候就会将参数名称编译到class文件中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Java8之前，代码编译为class文件后，方法参数的类型固定，但是方法名称会丢失，方法名称会变成arg0、arg1….。在Java8开始可以在class文件中保留参数名。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>消息中间件选型分析</title>
    <link href="http://yoursite.com/2019/05/07/JMS-2/"/>
    <id>http://yoursite.com/2019/05/07/JMS-2/</id>
    <published>2019-05-07T02:44:56.000Z</published>
    <updated>2019-08-28T08:10:09.984Z</updated>
    
    <content type="html"><![CDATA[<p>kafka和RabbitMQ的分析请查看博文：<a href="https://blog.csdn.net/u013256816/article/details/79838428" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/79838428</a><br>MQ详解比较查看博文：<br>    <a href="https://blog.csdn.net/wqc19920906/article/details/82193316" target="_blank" rel="noopener">https://blog.csdn.net/wqc19920906/article/details/82193316</a><br>    <a href="https://blog.csdn.net/wqc19920906/article/details/82193593" target="_blank" rel="noopener">https://blog.csdn.net/wqc19920906/article/details/82193593</a></p><p>RabbitMQ学习参考：<a href="https://blog.csdn.net/wqc19920906/article/details/82193942" target="_blank" rel="noopener">https://blog.csdn.net/wqc19920906/article/details/82193942</a></p><p>MQ遵循了JMS规范，kafka没有遵循JMS规范。kafka利用文件系统来管理消息的生命周期。<br><img src="/2019/05/07/JMS-2/SourceTreeSetup-2.4.8.0.exe" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;kafka和RabbitMQ的分析请查看博文：&lt;a href=&quot;https://blog.csdn.net/u013256816/article/details/79838428&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.cs
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Idea 工具的使用日志</title>
    <link href="http://yoursite.com/2019/05/06/idea-1/"/>
    <id>http://yoursite.com/2019/05/06/idea-1/</id>
    <published>2019-05-06T02:25:49.000Z</published>
    <updated>2019-08-28T08:09:58.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提升编译速度方法"><a href="#提升编译速度方法" class="headerlink" title="提升编译速度方法"></a>提升编译速度方法</h2><h3 id="开启并行编译功能"><a href="#开启并行编译功能" class="headerlink" title="开启并行编译功能"></a>开启并行编译功能</h3><pre><code>设置编译器在Compiler中勾选Compile independent modules in parallel并开启automatic和parallelized选项，打开并行编译功能。</code></pre><h3 id="增加Idea工具内存"><a href="#增加Idea工具内存" class="headerlink" title="增加Idea工具内存"></a>增加Idea工具内存</h3><pre><code>在bin目录下的vmoptions文件中修改内存分配。或者在Help中编辑Edit Custom VM Options。</code></pre><h3 id="查看Idea实时使用内存情况"><a href="#查看Idea实时使用内存情况" class="headerlink" title="查看Idea实时使用内存情况"></a>查看Idea实时使用内存情况</h3><pre><code>勾选Apparance的Show memory indicator。</code></pre><h2 id="Git-的-smart-checkout-和-force-checkout-的区别"><a href="#Git-的-smart-checkout-和-force-checkout-的区别" class="headerlink" title="Git 的 smart checkout 和 force checkout 的区别"></a>Git 的 smart checkout 和 force checkout 的区别</h2><p>比如说我从Dev切换回开发分支时,要是dev某个文件跟开发分支冲突时,他就会弹出一个窗，说这部分文件冲突，问你要怎么处理<br>smart checkout就会把冲突的这部分内容带到开发分支（如果你没有点进窗口的那些文件处理冲突的话）<br>force checkout就不会把冲突的这部分内容带到开发分支</p><h3 id="Idea开启自动编译"><a href="#Idea开启自动编译" class="headerlink" title="Idea开启自动编译"></a>Idea开启自动编译</h3><p>进入设置setting，Build,Execut, Deployment -&gt; Compiler 勾选右侧的Build Project automatically</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;提升编译速度方法&quot;&gt;&lt;a href=&quot;#提升编译速度方法&quot; class=&quot;headerlink&quot; title=&quot;提升编译速度方法&quot;&gt;&lt;/a&gt;提升编译速度方法&lt;/h2&gt;&lt;h3 id=&quot;开启并行编译功能&quot;&gt;&lt;a href=&quot;#开启并行编译功能&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Grails中配置Spring AOP</title>
    <link href="http://yoursite.com/2019/05/05/grails-1/"/>
    <id>http://yoursite.com/2019/05/05/grails-1/</id>
    <published>2019-05-05T05:25:01.000Z</published>
    <updated>2019-08-28T08:09:47.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Grails中集成Spring-AOP"><a href="#Grails中集成Spring-AOP" class="headerlink" title="Grails中集成Spring AOP"></a>Grails中集成Spring AOP</h3><ul><li><p>首先，我们必须在resources.groovy中添加Spring AOP的配置</p></li><li><p>现在在resources.groovy中编写以下代码行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beans = &#123;</span><br><span class="line">xmlns aop:&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">aspectBean(com.test.aop.LoggerInterceptor)</span><br><span class="line">aop.config(&quot;proxy-target-class&quot;:true) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在本例中，我们使用aspectBean（com.test.aop.LoggerInterceptor）创建AOP类的bean。</p></li><li><p>aop.config（“proxy-target-class”：true）它启用AOP来创建目标类的代理。</p></li><li><p>创建包含AOP实现的Groovy类。</p></li><li><p>我将使用AOP显示记录功能的示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">beans = &#123;</span><br><span class="line">package com.test.aop;</span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.After;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">@Aspect</span><br><span class="line">public class LoggerInterceptor &#123;</span><br><span class="line">private static Logger logger = LoggerFactory.getLogger(LoggerInterceptor.class);</span><br><span class="line">@Before(&quot;within(com.service..*)&quot;)</span><br><span class="line">public void logBefore(JoinPoint joinPoint)&#123;</span><br><span class="line">String logMessage = String.format(&quot;Beginning of each method: %s.%s(%s)&quot;,</span><br><span class="line">joinPoint.getTarget().getClass().getName(),</span><br><span class="line">joinPoint.getSignature().getName(),</span><br><span class="line">Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">logger.info(logMessage);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  @Aspect：Spring会自动检测任何带有注释为方面的类的bean。</p><p>  @Before：在匹配方法之前执行的之前的建议。</p><p>  JoinPoint：提供对当前连接点的访问（目标对象，建议方法的描述，参数类型，参数值等）。</p><p>  within（com.service .. <em>）：此方法将在调用com.service包下的服务类中的任何方法之前执行。</em></p><p>  您可以轻松地将建议应用于任何公共方法，任何参数化方法到任何类。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Grails中集成Spring-AOP&quot;&gt;&lt;a href=&quot;#Grails中集成Spring-AOP&quot; class=&quot;headerlink&quot; title=&quot;Grails中集成Spring AOP&quot;&gt;&lt;/a&gt;Grails中集成Spring AOP&lt;/h3&gt;&lt;ul&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VIM 操作命令大全</title>
    <link href="http://yoursite.com/2019/04/30/vim-1/"/>
    <id>http://yoursite.com/2019/04/30/vim-1/</id>
    <published>2019-04-30T02:22:38.000Z</published>
    <updated>2019-08-28T08:11:13.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-关于Vim"><a href="#1-关于Vim" class="headerlink" title="1. 关于Vim"></a>1. 关于Vim</h3><h4 id="1-1-Vim的几种模式"><a href="#1-1-Vim的几种模式" class="headerlink" title="1.1 Vim的几种模式"></a>1.1 Vim的几种模式</h4><pre><code>* 正常模式：可以使用快捷键命令，或按:输入命令行。* 插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。* 可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。* 替换模式：正常模式下，按R进入。</code></pre><h3 id="2-启动Vim"><a href="#2-启动Vim" class="headerlink" title="2. 启动Vim"></a>2. 启动Vim</h3><pre><code>* vim -c cmd file: 在打开文件前，先执行指定的命令；* vim -r file: 恢复上次异常退出的文件；* vim -R file: 以只读的方式打开文件，但可以强制保存；* vim -M file: 以只读的方式打开文件，不可以强制保存；* vim -y num file: 将编辑窗口的大小设为num行；* vim + file: 从文件的末尾开始；* vim +num file: 从第num行开始；* vim +/string file: 打开file，并将光标停留在第一个找到的string上。* vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</code></pre><h3 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3. 文档操作"></a>3. 文档操作</h3><pre><code>* :e file –关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。* :e! file –放弃对当前文件的修改，编辑新的文件。* :e+file – 开始新的文件，并从文件尾开始编辑。* :e+n file – 开始新的文件，并从第n行开始编辑。* :enew –编译一个未命名的新文档。(CTRL-W n)* :e – 重新加载当前文档。* :e! – 重新加载当前文档，并丢弃已做的改动。* :e#或ctrl+^ – 回到刚才编辑的文件，很实用。* :f或ctrl+g – 显示文档名，是否修改，和光标位置。* :f filename – 改变编辑的文件名，这时再保存相当于另存为。* gf – 打开以光标所在字符串为文件名的文件。* :w – 保存修改。* :n1,n2w filename – 选择性保存从某n1行到另n2行的内容。* :wq – 保存并退出。* ZZ – 保存并退出。* :x – 保存并退出。* :q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)* :saveas newfilename – 另存为* :browse e – 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：* :set browsedir=last – 用上次访问过的目录（默认）；* :set browsedir=buffer – 用当前文件所在目录；* :set browsedir=current – 用当前工作目录；* :Sex – 水平分割一个窗口，浏览文件系统；* :Vex – 垂直分割一个窗口，浏览文件系统；</code></pre><h3 id="4-光标的移动"><a href="#4-光标的移动" class="headerlink" title="4. 光标的移动"></a>4. 光标的移动</h3><h4 id="4-1-基本移动"><a href="#4-1-基本移动" class="headerlink" title="4.1 基本移动"></a>4.1 基本移动</h4><p>以下移动都是在normal模式下。</p><pre><code>* h或退格: 左移一个字符；* l或空格: 右移一个字符；* j: 下移一行；* k: 上移一行；* gj: 移动到一段内的下一行；* gk: 移动到一段内的上一行；* +或Enter: 把光标移至下一行第一个非空白字符。* -: 把光标移至上一行第一个非空白字符。* w: 前移一个单词，光标停在下一个单词开头；* W: 移动下一个单词开头，但忽略一些标点；* e: 前移一个单词，光标停在下一个单词末尾；* E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；* b: 后移一个单词，光标停在上一个单词开头；* B: 移动到上一个单词开头，忽略一些标点；* ge: 后移一个单词，光标停在上一个单词末尾；* gE: 同 ge ，不过‘单词’包含单词相邻的标点。* (: 前移1句。* ): 后移1句。* {: 前移1段。* }: 后移1段。* fc: 把光标移到同一行的下一个c字符处* Fc: 把光标移到同一行的上一个c字符处* tc: 把光标移到同一行的下一个c字符前* Tc: 把光标移到同一行的上一个c字符后* ;: 配合f &amp; t使用，重复一次* ,: 配合f &amp; t使用，反向重复一次* 上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。* * 0: 移动到行首。* g0: 移到光标所在屏幕行行首。* ^: 移动到本行第一个非空白字符。* g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。* : 移动光标所在屏幕行行尾。* n|: 把光标移到递n列上。* nG: 到文件第n行。* :n&lt;cr&gt; 移动到第n行。* :$&lt;cr&gt; 移动到最后一行。* H: 把光标移到屏幕最顶端一行。* M: 把光标移到屏幕中间一行。* L: 把光标移到屏幕最底端一行。* gg: 到文件头部。* G: 到文件尾部。</code></pre><h4 id="4-2-翻屏"><a href="#4-2-翻屏" class="headerlink" title="4.2 翻屏"></a>4.2 翻屏</h4><pre><code>* ctrl+f: 下翻一屏。* ctrl+b: 上翻一屏。* ctrl+d: 下翻半屏。* ctrl+u: 上翻半屏。* ctrl+e: 向下滚动一行。* ctrl+y: 向上滚动一行。* n%: 到文件n%的位置。* zz: 将当前行移动到屏幕中央。* zt: 将当前行移动到屏幕顶端。* zb: 将当前行移动到屏幕底端。</code></pre><h4 id="4-3-标记"><a href="#4-3-标记" class="headerlink" title="4.3 标记"></a>4.3 标记</h4><p>使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 后退 和 前进 。</p><pre><code>* m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。* m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。* `{a-z}: 移动到标记位置。* ‘{a-z}: 移动到标记行的行首。* `{0-9}：回到上[2-10]次关闭vim时最后离开的位置。* “: 移动到上次编辑的位置。”也可以，不过“精确到列，而”精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。* `”: 移动到上次离开的地方。* `.: 移动到最后改动的地方。* :marks 显示所有标记。* :delmarks a b – 删除标记a和b。* :delmarks a-c – 删除标记a、b和c。* :delmarks a c-f – 删除标记a、c、d、e、f。* :delmarks! – 删除当前缓冲区的所有标记。* :help mark-motions 查看更多关于mark的知识。</code></pre><h3 id="5-插入文本"><a href="#5-插入文本" class="headerlink" title="5. 插入文本"></a>5. 插入文本</h3><h4 id="5-1-基本插入"><a href="#5-1-基本插入" class="headerlink" title="5.1 基本插入"></a>5.1 基本插入</h4><pre><code>* i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+&lt;esc&gt;就插入了36个+组成的分割线。* I: 在当前行第一个非空字符前插入；* gI: 在当前行第一列插入；* a: 在光标后插入；* A: 在当前行最后插入；* o: 在下面新建一行插入；* O: 在上面新建一行插入；* :r filename在当前位置插入另一个文件的内容。* :[n]r filename在第n行插入另一个文件的内容。* :r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。</code></pre><h4 id="5-2-改写插入"><a href="#5-2-改写插入" class="headerlink" title="5.2 改写插入"></a>5.2 改写插入</h4><pre><code>* c[n]w: 改写光标后1(n)个词。* c[n]l: 改写光标后n个字母。* c[n]h: 改写光标前n个字母。* [n]cc: 修改当前[n]行。* [n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。* [n]S: 删除指定数目的行，并以所输入文本代替之。</code></pre><p>注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。</p><h3 id="6-剪切复制和寄存器"><a href="#6-剪切复制和寄存器" class="headerlink" title="6. 剪切复制和寄存器"></a>6. 剪切复制和寄存器</h3><h4 id="6-1-剪切和复制、粘贴"><a href="#6-1-剪切和复制、粘贴" class="headerlink" title="6.1 剪切和复制、粘贴"></a>6.1 剪切和复制、粘贴</h4><pre><code>* [n]x: 剪切光标右边n个字符，相当于d[n]l。* [n]X: 剪切光标左边n个字符，相当于d[n]h。* y: 复制在可视模式下选中的文本。* yy or Y: 复制整行文本。* y[n]w: 复制一(n)个词。* y[n]l: 复制光标右边1(n)个字符。* y[n]h: 复制光标左边1(n)个字符。* yor D: 删除（剪切）当前位置到行尾的内容。* d[n]w: 删除（剪切）1(n)个单词* d[n]l: 删除（剪切）光标右边1(n)个字符。* d[n]h: 删除（剪切）光标左边1(n)个字符。* d0: 删除（剪切）当前位置到行首的内容* [n] dd: 删除（剪切）1(n)行。* :m,nd&lt;cr&gt; 剪切m行到n行的内容。* d1G或dgg: 剪切光标以上的所有行。* dG: 剪切光标以下的所有行。* daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。* d/f&lt;cr&gt;：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。* p: 在光标之后粘贴。* P: 在光标之前粘贴。</code></pre><h4 id="6-2-文本对象"><a href="#6-2-文本对象" class="headerlink" title="6.2 文本对象"></a>6.2 文本对象</h4><pre><code>* aw：一个词* as：一句。* ap：一段。* ab：一块（包含在圆括号中的）。* y, d, c, v都可以跟文本对象。</code></pre><h4 id="6-3-寄存器"><a href="#6-3-寄存器" class="headerlink" title="6.3 寄存器"></a>6.3 寄存器</h4><pre><code>* a-z：都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。* A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如”Ayy把当前行的内容追加到a寄存器中。* :reg 显示所有寄存器的内容。* &quot;&quot;：不加寄存器索引时，默认使用的寄存器。* &quot;*：当前选择缓冲区，”*yy把当前行的内容放入当前选择缓冲区。* &quot;+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。</code></pre><h3 id="7-查找与替换"><a href="#7-查找与替换" class="headerlink" title="7. 查找与替换"></a>7. 查找与替换</h3><h4 id="7-1-查找"><a href="#7-1-查找" class="headerlink" title="7.1 查找"></a>7.1 查找</h4><pre><code>* /something: 在后面的文本中查找something。* ?something: 在前面的文本中查找something。* /pattern/+number: 将光标停在包含pattern的行后面第number行上。* /pattern/-number: 将光标停在包含pattern的行前面第number行上。* n: 向后查找下一个。* N: 向前查找下一个。可以用grep或vimgrep查找一个模式都在哪些地方出现过，其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。用法为： :vim[grep]/pattern/[g] [j] filesg的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。j的含义是grep结束后，结果停在第j项，默认是停在第一项。vimgrep前面可以加数字限定搜索结果的上限，如:1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：:vim/^d{1,}./ %然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，就更像个目录了。</code></pre><h4 id="7-2-替换"><a href="#7-2-替换" class="headerlink" title="7.2 替换"></a>7.2 替换</h4><pre><code>* :s/old/new - 用new替换当前行第一个old。* :s/old/new/g - 用new替换当前行所有的old。* :n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。* :%s/old/new/g - 用new替换文件中所有的old。* :%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。* :%s/表示行尾。* 所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，语法为 :[range]g/pattern/command例如 :%g/^ xyz/normal dd。表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。关于range的规定为：* 如果不指定range，则表示当前行。* m,n: 从m行到n行。* 0: 最开始一行（可能是这样）。* $: 最后一行* .: 当前行* %: 所有行</code></pre><h4 id="7-3-正则表达式"><a href="#7-3-正则表达式" class="headerlink" title="7.3 正则表达式"></a>7.3 正则表达式</h4><p>高级的查找替换就要用到正则表达式。</p><pre><code>* \d: 表示十进制数（我猜的）* \s: 表示空格* \S: 非空字符* \a: 英文字母* \|: 表示 或* \.: 表示.* {m,n}: 表示m到n个字符。这要和 \s与\a等连用，如 \a\{m,n} 表示m 到n个英文字母。* {m,}: 表示m到无限多个字符。* **: 当前目录下的所有子目录。</code></pre><p>:help pattern得到更多帮助。</p><h3 id="8-排版"><a href="#8-排版" class="headerlink" title="8. 排版"></a>8. 排版</h3><h4 id="8-1-基本排版"><a href="#8-1-基本排版" class="headerlink" title="8.1 基本排版"></a>8.1 基本排版</h4><pre><code>* &lt;&lt; 向左缩进一个shiftwidth* \&gt;\&gt; 向右缩进一个shiftwidth* :ce(nter) 本行文字居中* :le(ft) 本行文字靠左* :ri(ght) 本行文字靠右* gq 对选中的文字重排，即对过长的文字进行断行* gqq 重排当前行* gqnq 重排n行* gqap 重排当前段* gqnap 重排n段* gqnj 重排当前行和下面n行* gqQ 重排当前段对文章末尾* J 拼接当前行和下一行* gJ 同 J ，不过合并后不留空格。</code></pre><h4 id="8-2-拼写检查"><a href="#8-2-拼写检查" class="headerlink" title="8.2 拼写检查"></a>8.2 拼写检查</h4><pre><code>* :set spell－开启拼写检查功能* :set nospell－关闭拼写检查功能* ]s－移到下一个拼写错误的单词* [s－作用与上一命令类似，但它是从相反方向进行搜索* z=－显示一个有关拼写错误单词的列表，可从中选择* zg－告诉拼写检查器该单词是拼写正确的* zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的</code></pre><h4 id="8-3-统计字数"><a href="#8-3-统计字数" class="headerlink" title="8.3 统计字数"></a>8.3 统计字数</h4><p>g ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。</p><h3 id="9-编辑多个文件"><a href="#9-编辑多个文件" class="headerlink" title="9. 编辑多个文件"></a>9. 编辑多个文件</h3><h4 id="9-1-一次编辑多个文件"><a href="#9-1-一次编辑多个文件" class="headerlink" title="9.1 一次编辑多个文件"></a>9.1 一次编辑多个文件</h4><p>我们可以一次打开多个文件，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim a.txt b.txt c.txt</span><br></pre></td></tr></table></figure><pre><code>* 使用:next(:n)编辑下一个文件。* :2n 编辑下2个文件。* 使用:previous或:N编辑上一个文件。* 使用:wnext，保存当前文件，并编辑下一个文件。* 使用:wprevious，保存当前文件，并编辑上一个文件。* 使用:args 显示文件列表。* :n filenames或:args filenames 指定新的文件列表。* vi -o filenames 在水平分割的多个窗口中编辑多个文件。* vi -O filenames 在垂直分割的多个窗口中编辑多个文件。</code></pre><h4 id="9-2-多标签编辑"><a href="#9-2-多标签编辑" class="headerlink" title="9.2 多标签编辑"></a>9.2 多标签编辑</h4><pre><code>* vim -p files: 打开多个文件，每个文件占用一个标签页。* :tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。* ^w gf – 在新的标签页里打开光标下路径指定的文件。* :tabn – 切换到下一个标签。Control + PageDown，也可以。* :tabp – 切换到上一个标签。Control + PageUp，也可以。* [n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。* :tab split – 将当前缓冲区的内容在新页签中打开。* :tabc[lose] – 关闭当前的标签页。* :tabo[nly] – 关闭其它的标签页。* :tabs – 列出所有的标签页和它们包含的窗口。* :tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</code></pre><h4 id="9-3-缓冲区"><a href="#9-3-缓冲区" class="headerlink" title="9.3 缓冲区"></a>9.3 缓冲区</h4><pre><code>* :buffers或:ls或:files 显示缓冲区列表。* ctrl+^：在最近两个缓冲区间切换。* :bn – 下一个缓冲区。* :bp – 上一个缓冲区。* :bl – 最后一个缓冲区。* :b[n]或:[n]b – 切换到第n个缓冲区。* :nbw(ipeout) – 彻底删除第n个缓冲区。* :nbd(elete) – 删除第n个缓冲区，并未真正删除，还在unlisted列表中。* :ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</code></pre><h3 id="10-分屏编辑"><a href="#10-分屏编辑" class="headerlink" title="10. 分屏编辑"></a>10. 分屏编辑</h3><pre><code>* vim -o file1 file2:水平分割窗口，同时打开file1和file2* vim -O file1 file2:垂直分割窗口，同时打开file1和file2</code></pre><p>10.1 水平分割<br>    * :split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。<br>    * :split filename – 水平分割窗口，并在新窗口中显示另一个文件。<br>    * :nsplit(:nsp) – 水平分割出一个n行高的窗口。<br>    * :[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N)<br>    * ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。<br>    * C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。</p><h4 id="10-2-垂直分割"><a href="#10-2-垂直分割" class="headerlink" title="10.2 垂直分割"></a>10.2 垂直分割</h4><pre><code>* :vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V)* :[N]vne[w] – 垂直分割出一个新窗口。* :vertical 水平分割的命令： 相应的垂直分割。</code></pre><h4 id="10-3-关闭子窗口"><a href="#10-3-关闭子窗口" class="headerlink" title="10.3 关闭子窗口"></a>10.3 关闭子窗口</h4><pre><code>* :qall – 关闭所有窗口，退出vim。* :wall – 保存所有修改过的窗口。* :only – 只保留当前窗口，关闭其它窗口。(CTRL-W o)* :close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )</code></pre><h4 id="10-4-调整窗口大小"><a href="#10-4-调整窗口大小" class="headerlink" title="10.4 调整窗口大小"></a>10.4 调整窗口大小</h4><pre><code>* ctrl+w + –当前窗口增高一行。也可以用n增高n行。* ctrl+w - –当前窗口减小一行。也可以用n减小n行。* ctrl+w _ –当前窗口扩展到尽可能的大。也可以用n设定行数。* :resize n – 当前窗口n行高。* ctrl+w = – 所有窗口同样高度。* n ctrl+w _ – 当前窗口的高度设定为n行。* ctrl+w &lt; –当前窗口减少一列。也可以用n减少n列。* ctrl+w &gt; –当前窗口增宽一列。也可以用n增宽n列。* ctrl+w | –当前窗口尽可能的宽。也可以用n设定列数。</code></pre><h4 id="10-5-切换和移动窗口"><a href="#10-5-切换和移动窗口" class="headerlink" title="10.5 切换和移动窗口"></a>10.5 切换和移动窗口</h4><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p><pre><code>* ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。* ctrl+w p: 切换到前一个窗口。* ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。* ctrl+w t(b):切换到最上（下）面的窗口。&lt;BR&gt;* ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。* ctrl+w r：旋转窗口的位置。* ctrl+w T: 将当前的窗口移动到新的标签页上。</code></pre><h3 id="11-快速编辑"><a href="#11-快速编辑" class="headerlink" title="11. 快速编辑"></a>11. 快速编辑</h3><h4 id="11-1-改变大小写"><a href="#11-1-改变大小写" class="headerlink" title="11.1 改变大小写"></a>11.1 改变大小写</h4><pre><code>* ~: 反转光标所在字符的大小写。* 可视模式下的U或u：把选中的文本变为大写或小写。* gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。</code></pre><h4 id="11-2-替换（normal模式）"><a href="#11-2-替换（normal模式）" class="headerlink" title="11.2 替换（normal模式）"></a>11.2 替换（normal模式）</h4><pre><code>* r: 替换光标处的字符，同样支持汉字。* R: 进入替换模式，按esc回到正常模式。</code></pre><h4 id="11-3-撤消与重做（normal模式）"><a href="#11-3-撤消与重做（normal模式）" class="headerlink" title="11.3 撤消与重做（normal模式）"></a>11.3 撤消与重做（normal模式）</h4><pre><code>* [n] u: 取消一(n)个改动。* :undo 5 – 撤销5个改变。* :undolist – 你的撤销历史。* ctrl + r: 重做最后的改动。* U: 取消当前行中所有的改动。* :earlier 4m – 回到4分钟前* :later 55s – 前进55秒</code></pre><h4 id="11-4-宏"><a href="#11-4-宏" class="headerlink" title="11.4 宏"></a>11.4 宏</h4><pre><code>* . –重复上一个编辑动作* qa：开始录制宏a（键盘操作记录）* q：停止录制* @a：播放宏a</code></pre><h3 id="12-编辑特殊文件"><a href="#12-编辑特殊文件" class="headerlink" title="12. 编辑特殊文件"></a>12. 编辑特殊文件</h3><h4 id="12-1-文件加解密"><a href="#12-1-文件加解密" class="headerlink" title="12.1 文件加解密"></a>12.1 文件加解密</h4><pre><code>* vim -x file: 开始编辑一个加密的文件。* :X – 为当前文件设置密码。* :set key= – 去除文件的密码。</code></pre><p>这里是 滇狐总结的比较高级的vi技巧。</p><h4 id="12-2-文件的编码"><a href="#12-2-文件的编码" class="headerlink" title="12.2 文件的编码"></a>12.2 文件的编码</h4><pre><code>* :e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。* :w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。* :set fenc或:set fileencoding，查看当前文件的编码。* 在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。</code></pre><p>让vim 正确处理文件格式和文件编码，有赖于 ~/.vimrc的正确配置</p><h4 id="12-3-文件格式"><a href="#12-3-文件格式" class="headerlink" title="12.3 文件格式"></a>12.3 文件格式</h4><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p><pre><code>* :e ++ff=dos filename, 让vim用dos格式打开这个文件。* :w ++ff=mac filename, 以mac格式存储这个文件。* :set ff，显示当前文件的格式。* 在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。</code></pre><h3 id="13-编程辅助"><a href="#13-编程辅助" class="headerlink" title="13. 编程辅助"></a>13. 编程辅助</h3><h4 id="13-1-一些按键"><a href="#13-1-一些按键" class="headerlink" title="13.1 一些按键"></a>13.1 一些按键</h4><pre><code>* gd: 跳转到局部变量的定义处；* gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；* g;: 上一个修改过的地方；* g,: 下一个修改过的地方；* [[: 跳转到上一个函数块开始，需要有单独一行的{。* ]]: 跳转到下一个函数块开始，需要有单独一行的{。* []: 跳转到上一个函数块结束，需要有单独一行的}。* ][: 跳转到下一个函数块结束，需要有单独一行的}。* [{: 跳转到当前块开始处；* ]}: 跳转到当前块结束处；* [/: 跳转到当前注释块开始处；* ]/: 跳转到当前注释块结束处；* %: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。</code></pre><p>下面的括号匹配对编程很实用的。</p><pre><code>* ci’, di’, yi’：修改、剪切或复制’之间的内容。* ca’, da’, ya’：修改、剪切或复制’之间的内容，包含’。* ci”, di”, yi”：修改、剪切或复制”之间的内容。* ca”, da”, ya”：修改、剪切或复制”之间的内容，包含”。* ci(, di(, yi(：修改、剪切或复制()之间的内容。* ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。* ci[, di[, yi[：修改、剪切或复制[]之间的内容。* ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。* ci{, di{, yi{：修改、剪切或复制{}之间的内容。* ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。* ci&lt;, di&lt;, yi&lt;：修改、剪切或复制&lt;&gt;之间的内容。* ca&lt;, da&lt;, ya&lt;：修改、剪切或复制&lt;&gt;之间的内容，包含&lt;&gt;。</code></pre><h4 id="13-2-ctags"><a href="#13-2-ctags" class="headerlink" title="13.2 ctags"></a>13.2 ctags</h4><pre><code>* ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags* :set tags=path/tags – 告诉ctags使用哪个tag文件* :tag xyz – 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t* :stag xyz – 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口* :ptag xyz – 在预览窗口中打开xyz的定义，热键是C-w }。* :pclose – 关闭预览窗口。热键是C-w z。* :pedit abc.h – 在预览窗口中编辑abc.h* :psearch abc – 搜索当前文件和当前文件include的文件，显示包含abc的行。</code></pre><p>有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p><pre><code>* :[n]tnext – 下一[n]个匹配。* :[n]tprev – 上一[n]个匹配。* :tfirst – 第一个匹配* :tlast – 最后一个匹配* :tselect tagname – 打开选择列表</code></pre><p>tab键补齐<br>    * :tag xyz&lt;tab&gt; – 补齐以xyz开头的tag名，继续按tab键，会显示其他的。<br>    * :tag /xyz<tab> – 会用名字中含有xyz的tag名补全。</tab></p><h4 id="13-3-cscope"><a href="#13-3-cscope" class="headerlink" title="13.3 cscope"></a>13.3 cscope</h4><pre><code>* cscope -Rbq: 生成cscope.out文件* :cs add /path/to/cscope.out /your/work/dir* :cs find c func – 查找func在哪些地方被调用* :cw – 打开quickfix窗口查看结果</code></pre><h4 id="13-4-gtags"><a href="#13-4-gtags" class="headerlink" title="13.4 gtags"></a>13.4 gtags</h4><p>Gtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。</p><pre><code>* :Gtags funcname 定位到 funcname 的定义处。* :Gtags -r funcname 查询 funcname被引用的地方。* :Gtags -s symbol 定位 symbol 出现的地方。* :Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。* :Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。* :Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示vm目录下的文件。</code></pre><h4 id="13-5-编译"><a href="#13-5-编译" class="headerlink" title="13.5 编译"></a>13.5 编译</h4><p>vim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。</p><p>如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.Java文件，你可以这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set makeprg=javac\ abc.java</span><br></pre></td></tr></table></figure><p>然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setl efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%#</span><br></pre></td></tr></table></figure><p>%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。</p><h4 id="13-6-快速修改窗口"><a href="#13-6-快速修改窗口" class="headerlink" title="13.6 快速修改窗口"></a>13.6 快速修改窗口</h4><p>其实是quickfix插件提供的功能， 对编译调试程序非常有用 :)</p><pre><code>* :copen – 打开快速修改窗口。* :cclose – 关闭快速修改窗口。</code></pre><p>快速修改窗口在make程序时非常有用，当make之后：</p><pre><code>* :cl – 在快速修改窗口中列出错误。* :cn – 定位到下一个错误。* :cp – 定位到上一个错误。* :cr – 定位到第一个错误。</code></pre><p>13.7 自动补全<br>    * C-x C-s – 拼写建议。<br>    * C-x C-v – 补全vim选项和命令。<br>    * C-x C-l – 整行补全。<br>    * C-x C-f – 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。<br>    * C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。<br>    * C-x C-o – 编程时可以补全关键字和函数名啊。<br>    * C-x C-i – 根据头文件内关键字补全。<br>    * C-x C-d – 补全宏定义。<br>    * C-x C-n – 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。<br>当弹出补全菜单后：</p><pre><code>* C-p 向前切换成员；* C-n 向后切换成员；* C-e 退出下拉菜单，并退回到原来录入的文字；* C-y 退出下拉菜单，并接受当前选项。</code></pre><h4 id="13-8-多行缩进缩出"><a href="#13-8-多行缩进缩出" class="headerlink" title="13.8 多行缩进缩出"></a>13.8 多行缩进缩出</h4><pre><code>* 正常模式下，按两下&gt;;光标所在行会缩进。* 如果先按了n，再按两下&gt;;，光标以下的n行会缩进。* 对应的，按两下&lt;;，光标所在行会缩出。* 如果在编辑代码文件，可以用=进行调整。* 在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。* 或者n =，调整n行代码的缩排。</code></pre><h4 id="13-9-折叠"><a href="#13-9-折叠" class="headerlink" title="13.9 折叠"></a>13.9 折叠</h4><pre><code>* zf – 创建折叠的命令，可以在一个可视区域上使用该命令；* zd – 删除当前行的折叠；* zD – 删除当前行的折叠；* zfap – 折叠光标所在的段；* zo – 打开折叠的文本；* zc – 收起折叠；* za – 打开/关闭当前折叠；* zr – 打开嵌套的折行；* zm – 收起嵌套的折行；* zR (zO) – 打开所有折行；* zM (zC) – 收起所有折行；* zj – 跳到下一个折叠处；* zk – 跳到上一个折叠处；* zi – enable/disable fold;</code></pre><h3 id="14-命令行"><a href="#14-命令行" class="headerlink" title="14. 命令行"></a>14. 命令行</h3><p>normal模式下按:进入命令行模式</p><h4 id="14-1-命令行模式下的快捷键："><a href="#14-1-命令行模式下的快捷键：" class="headerlink" title="14.1 命令行模式下的快捷键："></a>14.1 命令行模式下的快捷键：</h4><pre><code>* 上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。* 左右方向键：左/右移一个字符。* C-w： 向前删除一个单词。* C-h： 向前删除一个字符，等同于Backspace。* C-u： 从当前位置移动到命令行开头。* C-b： 移动到命令行开头。* C-e： 移动到命令行末尾。* Shift-Left： 左移一个单词。* Shift-Right： 右移一个单词。* @： 重复上一次的冒号命令。* q： 正常模式下，q然后按’:’，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。* q/和q? 可以打开查找历史记录。</code></pre><h4 id="14-2-执行外部命令"><a href="#14-2-执行外部命令" class="headerlink" title="14.2 执行外部命令"></a>14.2 执行外部命令</h4><pre><code>* :! cmd 执行外部命令。* :!! 执行上一次的外部命令。* :sh 调用shell，用exit返回vim。* :r !cmd 将命令的返回结果插入文件当前位置。* :m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。</code></pre><h3 id="15-其它"><a href="#15-其它" class="headerlink" title="15. 其它"></a>15. 其它</h3><h4 id="15-1-工作目录"><a href="#15-1-工作目录" class="headerlink" title="15.1 工作目录"></a>15.1 工作目录</h4><pre><code>* :pwd 显示vim的工作目录。* :cd path 改变vim的工作目录。* :set autochdir 可以让vim 根据编辑的文件自动切换工作目录。</code></pre><h4 id="15-2-一些快捷键（收集中）"><a href="#15-2-一些快捷键（收集中）" class="headerlink" title="15.2 一些快捷键（收集中）"></a>15.2 一些快捷键（收集中）</h4><pre><code>* K: 打开光标所在词的manpage。* *: 向下搜索光标所在词。* g*: 同上，但部分符合即可。* \#: 向上搜索光标所在词。* g#: 同上，但部分符合即可。* g C-g: 统计全文或统计部分的字数。</code></pre><h4 id="15-3-在线帮助"><a href="#15-3-在线帮助" class="headerlink" title="15.3 在线帮助"></a>15.3 在线帮助</h4><pre><code>* :h(elp)或F1 打开总的帮助。* :help user-manual 打开用户手册。* 命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。* :helptags somepath 为somepath中的文档生成索引。* :helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。* Ctrl+] 跳转到tag主题，Ctrl+t 跳回。* :ver 显示版本信息。</code></pre><h4 id="15-4-一些小功能"><a href="#15-4-一些小功能" class="headerlink" title="15.4 一些小功能"></a>15.4 一些小功能</h4><pre><code>* 计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-关于Vim&quot;&gt;&lt;a href=&quot;#1-关于Vim&quot; class=&quot;headerlink&quot; title=&quot;1. 关于Vim&quot;&gt;&lt;/a&gt;1. 关于Vim&lt;/h3&gt;&lt;h4 id=&quot;1-1-Vim的几种模式&quot;&gt;&lt;a href=&quot;#1-1-Vim的几种模式&quot; class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式最终一致性事务</title>
    <link href="http://yoursite.com/2019/04/29/distributed-2/"/>
    <id>http://yoursite.com/2019/04/29/distributed-2/</id>
    <published>2019-04-29T06:48:10.000Z</published>
    <updated>2019-08-28T08:09:40.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、强一致性事务的瓶颈"><a href="#一、强一致性事务的瓶颈" class="headerlink" title="一、强一致性事务的瓶颈"></a>一、强一致性事务的瓶颈</h3><p>　　在《分布式强一致性事务》一文中介绍了分布式事务的常用协议2PC二阶段提交，虽然2PC能在很大程度上实现分布式事务中各节点的ACID，但也存在同步阻塞问题，协调者单点故障，协调者因网络原因导致的通知不周或收不全参与者回复导致的异常等问题。</p><p>　　同时，即使能稳定的使用二阶段提交实现分布式事务，但是2PC通信过程中产生的耗时是巨大的，类似淘宝网，下完一个订单后可能需要与计费中心，订单中心，入库，出库等很多子系统打交道，此过程中带来的开销是不能接受的，等到所有流程通知响应完再返回告知用户下单成功，这样的体验也是极差的。</p><p>　　为此，我们会比较容易想到用MQ来代替这个过程，因为MQ具有异步发起，子操作并行以及解耦子系统的特性，可以极大的提高用户体验。</p><h3 id="二、基于MQ的最终一致性"><a href="#二、基于MQ的最终一致性" class="headerlink" title="二、基于MQ的最终一致性"></a>二、基于MQ的最终一致性</h3><p>　　通过借助MQ队列，处理完业务逻辑后发送消息给消费方，并确保消息是发送成功的，之后消费方消费MQ队列来处理业务逻辑，如果消费并处理成功，则结束，如果没有成功，则重试，直到成功。若重试成功，但业务处理失败，则由人工介入处理（但消费成功，处理失败的场景是极少见的）。</p><h3 id="三、实现思路"><a href="#三、实现思路" class="headerlink" title="三、实现思路"></a>三、实现思路</h3><p>　　通过MQ异步可靠发送，幂等等策略来保证数据的最终一致性，会不可避免的对业务有一定的侵入。</p><p><strong>异步+可靠发送消费思路：</strong></p><p><strong>Producer：</strong>需要在业务表所在的库额外建一个消息表，确认表。消息表记录消息发送状态。消息表和业务数据要在一个本地事务里提交。消息表可以比较简单，有消息id，消息对应执行的方法，创建时间，发送状态即可，当业务逻辑执行成功，即向消费方发送消息，并向消息表插入一条消息，状态为已发送。</p><p><strong>Consumer：</strong>从MQ队列消费完消息后，处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，那发送给生产方一个confirm消息，Producer会将这条消息插入确认表，状态为已确认，表明整个流程已经处理成功了。如果处理失败，可以考虑发送给Producer一个failed消息，Producer同样会将这条消息插入确认表，只是状态为确认失败。</p><p><strong>重试机制：</strong>Producer有一个定时任务，即扫描已发送成功但确认状态为失败的消息，当扫描到有失败的消息时，此时有两个选择， 一是根据这条消息对应的执行方法，去作发送方业务逻辑上的回滚，或通过执行对应的反向sql进行回滚。二是去重发这条失败，即Producer的重试机制，可以设置重试发送的次数，直到消费方确认成功，若到达重试次数仍未有确认成功的状态，则将该消息丢入死信队列，由人工介入重发或进行手工处理。</p><p>　　注：由于每个节点都可能同时是Producer也是Consumer，所以使用到该方案的服务节点都应该在业务表所在库去创建消息表和确认表。</p><p><strong>幂等机制：</strong>在上面的描述中，业务的执行，消息的发送和插入消息表由于在一个本地事务中，所以保证了可靠发送。而消费方处理失败后，有发送方定时重发和私信队列人工处理，也保证了可靠消费（实际生产中，消费方消费后处理业务失败的场景极为少见）。这整个流程保证了可靠发送与可靠消费，但却保证不了一个问题，即消息可能重复发送或重复消费。</p><p>　　比如定时任务设置的是五分钟，当扫描到一条已发送但未确认的消息时，会进行发送，如果消费方处理时间较长，五分钟内依旧得不到确认成功的答复，则可能扫描到该消息又进行了重发，这样重复发送又可能导致了消费方重复消费，在一个调用过程中，保证消息只被发送一次和只被消费一次，是至关重要的。</p><p>　　此时引入幂等的概念就极其重要，可以在业务表所在库中增加一张幂等表。如在Producer节点的幂等表记录每条消息的发送次数，保证只能有一次发送，Consumer节点的幂等表记录每条消息的消费次数，保证只能有一次消费，因为每条消息都有一个唯一的消息id，所以可以以消息id来作为判断的依据。</p><p>　　当Producer产生一条消息时，则将这条消息记录进幂等表，表示该条消息已发送。当消费方返回确认成功时，将消息插入确认表，状态为成功，此时整个流程完结。当返回确认失败时，除了要将消息插入确认表中，状态为失败外，还要将幂等表中该消息id对应的发送记录置为0，方便后面定时器根据发送记录进行重发。若对失败消息的处理选择的是逻辑上的回滚，则可以省去对幂等表的操作。</p><p>　　当Consumer消费一条消息，并处理完业务逻辑时，则将这条消息记录进幂等表，表示该条消息已消费。当再次消费消息时，可前往幂等表进行判断，存在相同的消息id时，则可以将该消息丢掉，不再重复消费。</p><p>　　以上描述仅提供参考，对于基于MQ的可靠时间，有许许多多的玩法，例如消费方消费消息，业务处理失败后，也向Producer发送确认成功的消息，自己把这条消息丢自己的死信队列去重试或人工干预，所以一个完整的可靠事件SDK需要提供不同方案对应的不同解决问题的流程。</p><h3 id="四、事务消息"><a href="#四、事务消息" class="headerlink" title="四、事务消息"></a>四、事务消息</h3><p>　   事务消息是一个理想的方案，即消息的发送和消费是自带事务的，即我们只要把消息扔到MQ，那么这个消息肯定会被消费成功。</p><p>　　生产方不用担心消息发送失败，不用担心消息丢失。而消费方如果消息处理失败了，还有机会继续消费，直到成功为止。</p><p>　　事务消息可以少去我们很多为了保持一致性而对业务逻辑上的侵入，但遗憾的是市面上大部分MQ中间件都不支持事务消息。</p><p>　　RocketMQ最新版本已经支持事务消息，但仍需经过时间的考验和成功产品的出现，才能保证基于MQ的最终一致性的春天到来，真正解决分布式事务这一分布式系统中最令人头疼的问题，没有之一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、强一致性事务的瓶颈&quot;&gt;&lt;a href=&quot;#一、强一致性事务的瓶颈&quot; class=&quot;headerlink&quot; title=&quot;一、强一致性事务的瓶颈&quot;&gt;&lt;/a&gt;一、强一致性事务的瓶颈&lt;/h3&gt;&lt;p&gt;　　在《分布式强一致性事务》一文中介绍了分布式事务的常用协议2PC二
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式强一致性事务</title>
    <link href="http://yoursite.com/2019/04/29/distributed-1/"/>
    <id>http://yoursite.com/2019/04/29/distributed-1/</id>
    <published>2019-04-29T06:40:15.000Z</published>
    <updated>2019-08-28T08:09:35.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、事务的概念"><a href="#一、事务的概念" class="headerlink" title="一、事务的概念"></a>一、事务的概念</h3><p>　　事务是一组操作的执行单元，相对于数据库操作来讲，事务管理的是一组SQL指令，比如增加，修改，删除等，事务的一致性，要求，这个事务内的操作必须全部执行成功，如果在此过程种出现了差错，比如有一条SQL语句没有执行成功，那么这一组操作都将全部回滚</p><p>　　最经典的例子便是：A向B汇款500元，B账户多了500元，这整个过程，要么全部正常执行，要么全部回滚，不然就会出现A扣款，B收不到钱，或者A没扣款，B收到500元的情况，这种场景是灾难性的。</p><p><strong>事务特性（ACID）</strong><br>　　（1）Atomic(原子性):要么都成功，要么都失败<br>　　（2）Consistent(一致性):数据应该不被破坏<br>　　（3）Isolate(隔离性):用户间操作不相混淆<br>　　（4）Durable(持久性):永久保存 </p><h3 id="二、本地事务和分布式事务"><a href="#二、本地事务和分布式事务" class="headerlink" title="二、本地事务和分布式事务"></a>二、本地事务和分布式事务</h3><p><strong>本地事务</strong>：本地事务是在同一个JVM实例中调用不同的资源形成事务，紧密依赖于底层资源管理器（例如数据库连接 )，事务处理局限在当前事务资源内。此种事务处理方式不存在对其他应用服务器或实例的依赖。</p><p>　　如上述说到的汇款案例来说，若两个过程都在同一个JVM实例中，使用同个数据库连接，则事务比较好控制，如下图：<br><img src="/2019/04/29/distributed-1/1.jpg" alt="info"></p><p><strong>分布式事务</strong>：分布式事务是在一个JVM实例中调用不同的服务形成事务，不同的服务可能不在同一个JVM实例中，可能涉及到操作多个数据库的事务，必须保证每个独立节点上的数据操作可以满足ACID。</p><p>　　如上述说到的汇款案例来说，若两个过程在不同的JVM实例中，使用不同的数据库连接，则事务不好控制，原因是A，B无法知道事务在其他地方所做的所有动作，无法实现事务的一致性，如下图，A,B各自使用自己的事务管理完成begin，commit，rollback等操作，AB整个过程是无法实现事务一致性的。<br><img src="/2019/04/29/distributed-1/2.jpg" alt="info"></p><h3 id="三、对分布式事务的处理"><a href="#三、对分布式事务的处理" class="headerlink" title="三、对分布式事务的处理"></a>三、对分布式事务的处理</h3><p>　　在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。但是相互独立的节点无法知道其他节点的事务执行情况，要保证所有节点上的写操作，要么全部提交，要么全部rollback，最好的办法就是引入coordinator，即协调者来协调和通知各个节点上的事务执行情况。</p><p>　　Java 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS：Java Transaction Service) 为 J2EE 平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。</p><p>　　由于事务管理器统一管理所有事务参与单元，则所有事务参与单元都应实现同一套协议，才方便事务管理器的管理，就好似一个老师A管理一班学生，所有学生按照老师约定好的形式完成作业，之后交由同一个老师批改，批改后统一退回。若同一个作业，部分学生按照A老师的标准完成，部分同学按照B老师的标准完成，再提交上去批改，则最终得到的结果就可能互相不一致了。</p><h3 id="四、XA协议"><a href="#四、XA协议" class="headerlink" title="四、XA协议"></a>四、XA协议</h3><p>　　分布式事务中，所有的事务单元都需要实现统一的协议，XA 就是定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商，或消息中间件厂商提供。</p><p>　　如下图，我们可以将 JTA 的事务管理器和资源管理器理解为两个方面：面向开发人员的使用接口（事务管理器）和面向服务提供商的实现接口（资源管理器），开发人员使用开发人员接口，实现应用程序对全局事务的支持；各提供商（数据库，消息中间件等）依据提供商接口（即XA接口）的规范提供事务资源管理功能；事务管理器（ Transaction Manager ）将应用对分布式事务的使用映射到实际的事务资源并在事务资源间进行协调与控制，使得 JTA 可以在异构事务资源之间执行协同沟通。<br><img src="/2019/04/29/distributed-1/3.jpg" alt="info"></p><h3 id="五、强一致性事务实现原理"><a href="#五、强一致性事务实现原理" class="headerlink" title="五、强一致性事务实现原理"></a>五、强一致性事务实现原理</h3><p>　　2PC，即二阶段提交，是分布式事务中一个很重要的协议，当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个coordinator，即协调者作为的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交或回滚。</p><p>　　二阶段提交的算法思路可以概括为： 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是回滚操作。</p><p>　　各参与者成功提交事务流程：</p><p>　　（1）在一个有A，B，C参与的事务中，引入一个协调者，用来协调和通知各参与者执行相应的事务动作，其中黑线为协调者发起的指令，红线为参与者响应的指令。</p><p>　　（2）协调者通知所有参与者节点准备提交事务，参与者节点执行事务操作，并将Undo信息和Redo信息写入日志，但此时不提交事务。</p><p>　　（3）协调者收到各参与者准备提交完成的指令，没有任何节点出错，此时通知所有节点提交事务。</p><p>　　（4）参与者节点正式完成提交操作，并释放在整个事务期间内占用的资源。</p><p>　　（5）协调者收到所有参与者确认提交完毕的答复，此时整个事务完成。<br><img src="/2019/04/29/distributed-1/4.jpg" alt="info"></p><p>各参与者提交事务失败流程：</p><p>　　（1）在一个有A，B，C参与的事务中，引入一个协调者，用来协调和通知各参与者执行相应的事务动作，其中黑线为协调者发起的指令，红线为参与者响应的指令。</p><p>　　（2）协调者通知所有参与者节点准备提交事务，参与者节点执行事务操作，并将Undo信息和Redo信息写入日志，但此时不提交事务，但此时B节点在准备执行操作事务时出现了异常，则返回给协调者准备失败的响应信息</p><p>　　（3）协调者虽然收到A跟C准备完成的响应，但B返回的状态是准备失败，此时进入通知所有参与者回滚的阶段</p><p>　　（4）参与者节点正式完成回滚操作，并释放在整个事务期间内占用的资源。</p><p>　　（5）协调者收到所有参与者确认回滚完毕的答复，此时整个事务完成<br><img src="/2019/04/29/distributed-1/5.jpg" alt="info"></p><p>结论：不管最后结果如何，第二阶段都会结束当前事务。</p><p>　　建议：少使用分布式事务，在分布式事务这个问题上，还很少有成熟牛逼的产品，而且分布式事务过程中，涉及到了各个节点的通知，二次通知，当节点多的时候，协调者的压力巨大，而且整个流程对业务的时间开销是巨大的，所以建议谨慎使用分布式事务，即使二阶段看似能处理好分布式节点的ACID问题，但是其本身也存在不小的问题。　</p><p><strong>1、同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p><p><strong>2、单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p><p><strong>3、数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p><p><strong>4、二阶段无法解决的问题</strong>：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><p>　　注：二阶段提交的缺点描述引用来自<a href="http://blog.jobbole.com/95632/。" target="_blank" rel="noopener">http://blog.jobbole.com/95632/。</a><br>    注：文章引用来自：<a href="https://www.cnblogs.com/jiyukai/p/9462312.html。" target="_blank" rel="noopener">https://www.cnblogs.com/jiyukai/p/9462312.html。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、事务的概念&quot;&gt;&lt;a href=&quot;#一、事务的概念&quot; class=&quot;headerlink&quot; title=&quot;一、事务的概念&quot;&gt;&lt;/a&gt;一、事务的概念&lt;/h3&gt;&lt;p&gt;　　事务是一组操作的执行单元，相对于数据库操作来讲，事务管理的是一组SQL指令，比如增加，修改，删除
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA消息服务JMS规范及原理详解</title>
    <link href="http://yoursite.com/2019/04/29/JMS-1/"/>
    <id>http://yoursite.com/2019/04/29/JMS-1/</id>
    <published>2019-04-29T03:04:46.000Z</published>
    <updated>2019-08-28T08:10:04.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p><p>JMS允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p><h3 id="二、常用术语介绍"><a href="#二、常用术语介绍" class="headerlink" title="二、常用术语介绍"></a>二、常用术语介绍</h3><pre><code>在提到JMS时，我们通常会说到一些术语，解释如下：</code></pre><ul><li>消息中间件（JMS Provider) ： 指提供了对JMS协议的第三方组件，比如ActiveMQ就是一个消息中间件，另外比较知名的还* 有KFA, Rabbit MQ等。</li><li>消息模式：分为点对点（Point to Point，即P2P）和发布/订阅（Pub/Sub)，对应的数据结构分别是队列（Queue)和主题（Topic)</li><li>消息（Message): 通信内容的载体，其结构主要分为消息头，属性和消息体，并且根据存储结构的不同分为好几种，后面会详细提到。</li><li>消息生产者：产生消息的一方，在P2P模式下，指消息发送者(Sender)，在P/S模式下指消息发布者(Publisher)</li><li>消息消费者：接收消息的一方，对应于两种模式分别是消息接收者（Receiver）和消息订阅者(Subscriber)                          </li></ul><h3 id="三、JMS基本概念及原理详解"><a href="#三、JMS基本概念及原理详解" class="headerlink" title="三、JMS基本概念及原理详解"></a>三、JMS基本概念及原理详解</h3><h4 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h4><p>　　JMS是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。</p><h4 id="2、体系架构"><a href="#2、体系架构" class="headerlink" title="2、体系架构"></a>2、体系架构</h4><p>　　JMS由以下元素组成。</p><p>　　1.JMS提供者<br>　　连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。</p><p>　　2.JMS客户<br>　　生产或消费消息的基于Java的应用程序或对象。</p><p>　　3.JMS生产者<br>　　创建并发送消息的JMS客户。</p><p>　　4.JMS消费者<br>　　接收消息的JMS客户。</p><p>　　5.JMS消息<br>　　包括可以在JMS客户之间传递的数据的对象</p><p>　　6.JMS队列<br>　　一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。</p><p>　　7.JMS主题<br>　　一种支持发送消息给多个订阅者的机制。</p><h4 id="3、JMS消息模型-即点对点和发布订阅模型"><a href="#3、JMS消息模型-即点对点和发布订阅模型" class="headerlink" title="3、JMS消息模型(即点对点和发布订阅模型)"></a>3、JMS消息模型(即点对点和发布订阅模型)</h4><p>　　　　1、Point-to-Point(P2P)</p><p>　　　　2、Publish/Subscribe(Pub/Sub)</p><h4 id="4、P2P"><a href="#4、P2P" class="headerlink" title="4、P2P"></a>4、P2P</h4><h5 id="1、P2P模式图效果"><a href="#1、P2P模式图效果" class="headerlink" title="1、P2P模式图效果"></a>1、P2P模式图效果</h5><p><img src="/2019/04/29/JMS-1/1.jpg" alt="info"></p><h5 id="2、涉及到的概念"><a href="#2、涉及到的概念" class="headerlink" title="2、涉及到的概念"></a>2、涉及到的概念</h5><ul><li>消息队列（Queue）</li><li>提供者(Sender)</li><li>消费者(Receiver)</li><li>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</li></ul><h5 id="3、P2P的特点"><a href="#3、P2P的特点" class="headerlink" title="3、P2P的特点　　　　"></a>3、P2P的特点　　　　</h5><ul><li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li><li>提供者和消费者之间在时间上没有依赖性，也就是说当提供者发送了消息之后，不管消费者有没有正在运行，它不会影响到消息被发送到队列</li><li>每条消息仅会传送给一个消费者。可能会有多个消费者在一个队列中侦听，但是每个队列中的消息只能被队列中的一个消费者所消费。</li><li>消息存在先后顺序。一个队列会按照消息服务器将消息放入队列中的顺序，把它们传送给消费者。当已被消费时，就会从队列头部将它们删除（除非使用了消息优先级）。</li><li>消费者在成功接收消息之后需向队列应答成功<br>　　　　PS:如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。</li></ul><h4 id="5、Pub-Sub（发布-订阅模式）"><a href="#5、Pub-Sub（发布-订阅模式）" class="headerlink" title="5、Pub/Sub（发布/订阅模式）"></a>5、Pub/Sub（发布/订阅模式）</h4><h5 id="1、Pub-Sub模式效果图"><a href="#1、Pub-Sub模式效果图" class="headerlink" title="1、Pub/Sub模式效果图"></a>1、Pub/Sub模式效果图</h5><p><img src="/2019/04/29/JMS-1/2.jpg" alt="info"></p><h5 id="2、涉及到的概念-1"><a href="#2、涉及到的概念-1" class="headerlink" title="2、涉及到的概念"></a>2、涉及到的概念</h5><ul><li>主题（Topic）</li><li>发布者（Publisher）</li><li>订阅者（Subscriber）</li></ul><p>　　　　PS:客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。　　</p><h5 id="3、Pub-Sub（发布-订阅模式）的特点"><a href="#3、Pub-Sub（发布-订阅模式）的特点" class="headerlink" title="3、Pub/Sub（发布/订阅模式）的特点"></a>3、Pub/Sub（发布/订阅模式）的特点</h5><ul><li>每个消息可以有多个消费者</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。</li><li>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li><li>每条消息都会传送给称为订阅者的多个消息消费者。订阅者有许多类型，包括持久型、非持久型和动态型。</li><li>发布者通常不会知道、也意识不到哪一个订阅者正在接收主题消息。</li><li>消息被推送给消费者，这意味着消息会传送给消费者，而无须请求。</li></ul><p>　　　　PS:如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</p><h4 id="6、关于消息的消费"><a href="#6、关于消息的消费" class="headerlink" title="6、关于消息的消费"></a>6、关于消息的消费</h4><p>　　在JMS中，消息的产生和消息是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。　　</p><h5 id="6-1、同步"><a href="#6-1、同步" class="headerlink" title="6.1、同步"></a>6.1、同步</h5><p>　　　　订阅者或消费者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞</p><h5 id="6-2、异步"><a href="#6-2、异步" class="headerlink" title="6.2、异步"></a>6.2、异步</h5><p>　　　　订阅者或消费者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</p><h4 id="7、JMS应用程序接口"><a href="#7、JMS应用程序接口" class="headerlink" title="7、JMS应用程序接口"></a>7、JMS应用程序接口</h4><h5 id="7-1、ConnectionFactory-接口-连接工厂"><a href="#7-1、ConnectionFactory-接口-连接工厂" class="headerlink" title="7.1、ConnectionFactory 接口(连接工厂)"></a>7.1、ConnectionFactory 接口(连接工厂)</h5><p>　　　　创建Connection对象的工厂，根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂分，<br>　　　　别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。　　</p><h5 id="7-2、Destination-接口-目标"><a href="#7-2、Destination-接口-目标" class="headerlink" title="7.2、Destination 接口(目标)"></a>7.2、Destination 接口(目标)</h5><p>　　　　Destination是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。<br>　　　　是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;<br>　　　　对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。<br>　　　　所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。</p><h5 id="7-3、Connection-接口-连接"><a href="#7-3、Connection-接口-连接" class="headerlink" title="7.3、Connection 接口(连接)"></a>7.3、Connection 接口(连接)</h5><p>　　　　Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。<br>　　　　Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</p><h5 id="7-4、Session-接口-会话"><a href="#7-4、Session-接口-会话" class="headerlink" title="7.4、Session 接口(会话)"></a>7.4、Session 接口(会话)</h5><p>　　　　Session是我们操作消息的接口。表示一个单线程的上下文，用于发送和接收消息。<br>　　　　由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。<br>　　　　可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。<br>　　　　同样，也分QueueSession和TopicSession。</p><h5 id="7-5、MessageProducer-接口-消息的生产者"><a href="#7-5、MessageProducer-接口-消息的生产者" class="headerlink" title="7.5、MessageProducer 接口(消息的生产者)"></a>7.5、MessageProducer 接口(消息的生产者)</h5><p>　　　　消息生产者由Session创建，并用于将消息发送到Destination。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。<br>　　　　同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</p><h5 id="7-6、MessageConsumer-接口-消息消费者"><a href="#7-6、MessageConsumer-接口-消息消费者" class="headerlink" title="7.6、MessageConsumer 接口(消息消费者)"></a>7.6、MessageConsumer 接口(消息消费者)</h5><p>　　　　消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。<br>　　　　可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。<br>　　　　当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</p><h5 id="7-7、Message-接口（消息）"><a href="#7-7、Message-接口（消息）" class="headerlink" title="7.7、Message 接口（消息）"></a>7.7、Message 接口（消息）</h5><p>　　　　是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。一个消息有三个主要部分：<br>　　　　1、消息头（必须）：包含用于识别和为消息寻找路由的操作设置。<br>　　　　2、一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。<br>　　　　3、一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。消息接口非常灵活，并提供了许多方式来定制消息的内容。</p><p>　　　　消息接口非常灵活，并提供了许多方式来定制消息的内容。</p><h5 id="7-8、MessageListener"><a href="#7-8、MessageListener" class="headerlink" title="7.8、MessageListener"></a>7.8、MessageListener</h5><p>　　　　消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。<br>　　　　EJB中的MDB（Message-Driven Bean）就是一种MessageListener。</p><h3 id="四、JMS提供者实现"><a href="#四、JMS提供者实现" class="headerlink" title="四、JMS提供者实现"></a>四、JMS提供者实现</h3><p>　　要使用Java消息服务，你必须要有一个JMS提供者，管理会话和队列。现在既有开源的提供者也有专有的提供者。<br>　　开源的提供者包括：Apache ActiveMQ、Kafka、WebMethods、阿里的RocketMQ等</p><p><strong>JMS是一个标准，具体还是依赖实现，当前常见的JMS实现有ActiveMQ、ZeroMQ、RabbitMQ等，Kafka是一种类似JMS的实现</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h3&gt;&lt;p&gt;JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（M
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kettle在centos7环境下的安装</title>
    <link href="http://yoursite.com/2019/04/26/kettle7/"/>
    <id>http://yoursite.com/2019/04/26/kettle7/</id>
    <published>2019-04-26T09:24:38.000Z</published>
    <updated>2019-08-28T08:10:44.877Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jdk-1-8-环境搭建。（必要）"><a href="#jdk-1-8-环境搭建。（必要）" class="headerlink" title="jdk 1.8 环境搭建。（必要）"></a>jdk 1.8 环境搭建。（必要）</h3><pre><code>这里关于jdk安装省略。</code></pre><h3 id="下载：在官网下载kettle的安装包8-2版本。"><a href="#下载：在官网下载kettle的安装包8-2版本。" class="headerlink" title="下载：在官网下载kettle的安装包8.2版本。"></a>下载：在官网下载kettle的安装包8.2版本。</h3><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><pre><code>先安装一些依赖项：</code></pre><p>yum -y install epel-release<br>yum -y install webkitgtk<br><strong>注：</strong><br>    这时候会发现没有webkitgtk包，因为centos7的相关软件源没有这个包，这时候可以：<br>    安装nux桌面相关软件包的一个专用软件源<br>    rpm -Uvh <a href="http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm" target="_blank" rel="noopener">http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm</a><br>    再执行前面的安装就会成功了；<br>    下面我们解压之前下载好的安装包<br>    yum install -y unzip;<br>    unzip pdi-ce-7.0.0.0-25.zip<br>    cd data-integration/<br>    赋予所有脚本执行权限：<br>    chmod +x -R *.sh;<br>linux下脚本的执行执行命令：<br>    trans 使用pan.sh 执行。<br>    job 使用 kitchen.sh执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;jdk-1-8-环境搭建。（必要）&quot;&gt;&lt;a href=&quot;#jdk-1-8-环境搭建。（必要）&quot; class=&quot;headerlink&quot; title=&quot;jdk 1.8 环境搭建。（必要）&quot;&gt;&lt;/a&gt;jdk 1.8 环境搭建。（必要）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;这里
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kettle 增量更新案例</title>
    <link href="http://yoursite.com/2019/04/26/kettle6/"/>
    <id>http://yoursite.com/2019/04/26/kettle6/</id>
    <published>2019-04-26T01:45:52.000Z</published>
    <updated>2019-08-28T09:19:44.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="增量更新问题分析"><a href="#增量更新问题分析" class="headerlink" title="增量更新问题分析"></a>增量更新问题分析</h3><p>假定在源数据表中有一个字段会记录数据的新增或修改时间，可以通过它对数据在时间维度上进行排序。通过中间表记录每次更新的时间戳，在下一个同步周期时，通过这个时间戳同步该时间戳以后的增量数据。通过时间戳来完成增量同步。</p><h3 id="作业流程"><a href="#作业流程" class="headerlink" title="作业流程"></a>作业流程</h3><ul><li>开始组件</li><li>建时间戳中间表</li><li>获取中间表的时间戳，并设置为全局变量</li><li>删除目标表中时间戳及时间戳以后的数据</li><li>抽取两个数据表的时间戳及时间戳以后的数据进行转换操作，并根据比对结果进行删除、新增或修改操作</li><li>更新时间戳</li></ul><h3 id="创建作业"><a href="#创建作业" class="headerlink" title="创建作业"></a>创建作业</h3><p>最终的作业截图如下（如何创建作业和使用组件这里不重复赘述）：<br><img src="/2019/04/26/kettle6/1.png" alt="info"><br>其中获取时间戳的trans截图如下：<br><img src="/2019/04/26/kettle6/2.png" alt="info"><br>增量更新数据trans截图如下：<br><img src="/2019/04/26/kettle6/3.png" alt="info"></p><h4 id="创建作业和DB连接"><a href="#创建作业和DB连接" class="headerlink" title="创建作业和DB连接"></a>创建作业和DB连接</h4><pre><code>打开Spoon工具，新建作业，然后在左侧主对象树DB连接中新建DB连接。创建连接并测试通过后可以在左侧DB连接下右键共享出来。因为在单个作业或者转换中新建的DB连接都是局域数据源，在其他转换和作业中是不能使用的，即使属于同一个作业下的不同转换，所以需要把他们共享，这样DB连接就会成为全局数据源，不用多次编辑。</code></pre><h4 id="建时间戳中间表"><a href="#建时间戳中间表" class="headerlink" title="建时间戳中间表"></a>建时间戳中间表</h4><pre><code>这一步是为了在目标数据库建中间表etl_temp,并插入初始的时间戳字段。</code></pre><p>本例中目标库使用postgresql数据库的创建中间表和初始化数据sql语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS etl_temp(id int primary key,time_stamp timestamp);</span><br><span class="line">INSERT INTO etl_temp (id,time_stamp) VALUES (1, to_timestamp(&apos;2016-04-25 15:04:28 605&apos;, &apos;YYYY-MM-DD HH24:MI:SS MS&apos;)) ON conflict(id) DO UPDATE SET time_stamp = to_timestamp(&apos;2016-04-25 15:04:28 605&apos;, &apos;YYYY-MM-DD HH24:MI:SS MS&apos;);</span><br></pre></td></tr></table></figure><h4 id="获取时间戳并设为变量"><a href="#获取时间戳并设为变量" class="headerlink" title="获取时间戳并设为变量"></a>获取时间戳并设为变量</h4><p>SQL代码和组件配置截图如下<br>获取上次更新时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select to_char(time_stamp, &apos;YYYY-MM-DD HH24:MI:SS MS&apos;) time_stamp from etl_temp where id=1 ;</span><br></pre></td></tr></table></figure><p>获取当前服务器时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select to_char(current_timestamp, &apos;YYYY-MM-DD HH24:MI:SS MS&apos;) as c_time;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/26/kettle6/4.png" alt="info"></p><h4 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h4><p>变量活动类型可以为该变量设置四种有效活动范围，分别是JVM、该Job、父Job和祖父Job<br><img src="/2019/04/26/kettle6/5.png" alt="info"></p><h4 id="删除目标表中时间戳及时间戳以后的数据"><a href="#删除目标表中时间戳及时间戳以后的数据" class="headerlink" title="删除目标表中时间戳及时间戳以后的数据"></a>删除目标表中时间戳及时间戳以后的数据</h4><p>这样做有两个好处：</p><p><strong>避免在同步中重复或者遗漏数据。</strong><br>    例如当时间戳在源数据表中不是唯一的，上一次同步周期最后一条数据的时间戳是2018-05-25 18:12:12,那么上一次同步周期结束后中间表中的时间戳就会更新为2018-05-25 18:12:12。如果在下一个同步周期时源数据表中仍然有时间戳为2018-05-25 18:12:12的新数据，那么同步就会出现数据不一致。采用大于时间戳的方式同步就会遗漏数据，采用等于时间戳的方式同步就会重复同步数据。<br><strong>增加健壮性</strong><br>    当作业异常结束后，不用做任何多余的操作就可以重启。因为会删除目标表中时间戳及时间戳以后的数据，所以不用担心数据一致性问题</p><h4 id="抽取、转换和更新数据"><a href="#抽取、转换和更新数据" class="headerlink" title="抽取、转换和更新数据"></a>抽取、转换和更新数据</h4><p>这一步才是真正的数据同步步骤，完成了数据的抽取、比对，并根据不同的比对结果删除、更新、插入或不做任何操作。设置如下图：<br><img src="/2019/04/26/kettle6/6.png" alt="info"><br>在组件中使用了上一步骤设置的变量，所以必须勾选使用变量替换<br>sql代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, major_version, minor_version, programme, status, &quot;_tenant_id&quot;, release_date FROM autopus_1.cm_cost_model where &quot;_is_deleted&quot; = false and (&quot;_create_date&quot; &gt; to_timestamp(&apos;$&#123;TIME_STAMP&#125;&apos;, &apos;YYYY-MM-DD HH24:MI:SS MS&apos;) or &quot;_update_date&quot;  &gt; to_timestamp(&apos;$&#123;TIME_STAMP&#125;&apos;, &apos;YYYY-MM-DD HH24:MI:SS MS&apos;));</span><br></pre></td></tr></table></figure><p>然后通过插入/更新更新数据到目标库。<br>更新成功后需要更新时间戳，为下次执行脚本时查询增量数据做准备。<br>下面是更新时间戳的sql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE public.etl_temp</span><br><span class="line">SET time_stamp=to_timestamp(&apos;$&#123;C_TIME&#125;&apos;, &apos;YYYY-MM-DD HH24:MI:SS MS&apos;)</span><br><span class="line">WHERE id=1;</span><br></pre></td></tr></table></figure><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>关于发送邮件组件网上有很多资料，就不多做介绍。特别强调一点，邮箱密码是 单独的授权码，而不是邮箱登录密码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;增量更新问题分析&quot;&gt;&lt;a href=&quot;#增量更新问题分析&quot; class=&quot;headerlink&quot; title=&quot;增量更新问题分析&quot;&gt;&lt;/a&gt;增量更新问题分析&lt;/h3&gt;&lt;p&gt;假定在源数据表中有一个字段会记录数据的新增或修改时间，可以通过它对数据在时间维度上进行排序。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kettle脚本开发示例</title>
    <link href="http://yoursite.com/2019/04/25/kettle5/"/>
    <id>http://yoursite.com/2019/04/25/kettle5/</id>
    <published>2019-04-25T10:29:59.000Z</published>
    <updated>2019-09-17T07:59:02.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本转换脚本开发（trans）"><a href="#基本转换脚本开发（trans）" class="headerlink" title="基本转换脚本开发（trans）"></a>基本转换脚本开发（trans）</h3><p>新建trans，在主对象树子服务器中右键，新建，填写数据库连接信息。<br><img src="/2019/04/25/kettle5/1.jpg" alt="info"></p><p>在核心对象中选择输入，拖动表输入控件，选择输出拖动插入/更新控件。<br><img src="/2019/04/25/kettle5/2.png" alt="info"></p><p>编辑表输入，选择你要连接的数据库，然后编写查询语句；可以使用 ${} 来表示变量，但需要勾选“替换sql语句里的变量”选项才会生效。<br><img src="/2019/04/25/kettle5/3.png" alt="info"></p><p>建议先不要设置变量，直接使用常量，在查询语句可以独立执行的情况下可以点击预览，预览数据。</p><p>在成功预览数据之后，通过按住shift键和鼠标左键连接两个组件。<br><img src="/2019/04/25/kettle5/5.png" alt="info"></p><p>编辑插入/更新组件，选择你要连接的数据库和目标表；可以通过“获取字段”按钮来在动候签表字段和流字段（需要上一步连接操作之后才可以），然后选择查询关键字，即查询条件。在更新字段一栏中，可以通过“获取和更新字段”按钮来自动获取表和流字段，然后选择需要更新的字段，也可以通过“编辑映射”按钮来手动调整映射关系或直接手动修改。<br><img src="/2019/04/25/kettle5/4.png" alt="info"></p><p>然后可以通过启动按钮来验证脚本是否正确，到此为止一个简单的脚本就完成了。</p><h3 id="任务开发（job）"><a href="#任务开发（job）" class="headerlink" title="任务开发（job）"></a>任务开发（job）</h3><p>选择新建job，核心对象中选择通用，使用组件Start， 可以配置任务的定时调度。<br><img src="/2019/04/25/kettle5/7.png" alt="info"></p><p>使用通用中的转换和作业等组件可以调度其他的trans或job。<br><img src="/2019/04/25/kettle5/8.jpg" alt="info"></p><p>选择之前我们写好的trans，至此一个简单的job就算完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本转换脚本开发（trans）&quot;&gt;&lt;a href=&quot;#基本转换脚本开发（trans）&quot; class=&quot;headerlink&quot; title=&quot;基本转换脚本开发（trans）&quot;&gt;&lt;/a&gt;基本转换脚本开发（trans）&lt;/h3&gt;&lt;p&gt;新建trans，在主对象树子服务器中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kettle分区、集群及并行</title>
    <link href="http://yoursite.com/2019/04/24/kettle4/"/>
    <id>http://yoursite.com/2019/04/24/kettle4/</id>
    <published>2019-04-24T08:15:09.000Z</published>
    <updated>2019-08-28T09:22:29.882Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Kettle的转换和作业可以在垂直和水平方面进行扩展。垂直扩展是尽可能利用单台服务器上的多CPU核数。水平扩展是使用多台机器资源，使他们并行计算。下面先谈谈转换内部的并行机制。</code></pre><h3 id="一-多线程"><a href="#一-多线程" class="headerlink" title="一.多线程"></a>一.多线程</h3><pre><code>默认情况下转换中的每一个步骤都事在单一隔离的线程里面并行执行，但可以为任何单一步骤增加线程数目，这叫做复制。这可以提高CPU时间消耗量大的转换步骤的性能。</code></pre><p><img src="/2019/04/24/kettle4/1.png" alt="*4代表了4个复制将在运行时被启动"></p><p><strong>Step：描述需要做的某项工作的定义或元数据。</strong><br><strong>Step copy：在步骤里定义的执行某项工作的一个并行工作线程</strong><br>    step仅仅是任务的定义，而一个step copy则表示一个实际执行的任务。</p><h4 id="记录行分发"><a href="#记录行分发" class="headerlink" title="记录行分发"></a>记录行分发</h4><pre><code>记录怎样分发给目标步骤复制？默认下，分发以循环方式执行。比如有N份复制，第一份复制获取第一条，第二份复制获取第二条，以此类推。</code></pre><h4 id="记录行合并"><a href="#记录行合并" class="headerlink" title="记录行合并"></a>记录行合并</h4><pre><code>记录合并发生在几个步骤或步骤复制发送多条记录给单个步骤复制时。</code></pre><p><img src="/2019/04/24/kettle4/2.png" alt="info"></p><h4 id="记录行再分发"><a href="#记录行再分发" class="headerlink" title="记录行再分发"></a>记录行再分发</h4><pre><code>在记录行再分发里，有X个步骤复制发送记录集给Y个目标步骤复制。</code></pre><p><img src="/2019/04/24/kettle4/3.png" alt="info"><br>    其等同于下图：<br><img src="/2019/04/24/kettle4/4.png" alt="info"></p><h4 id="数据流水线"><a href="#数据流水线" class="headerlink" title="数据流水线"></a>数据流水线</h4><pre><code>数据流水线是再分发的一个特例，它的来源和目标步骤复制是一样的（X==Y）。这种情况下，记录集不是通过所有步骤复制被再分发的，相反，由源步骤复制1产生的记录集被发送到具有相同编号的目标步骤复制。例如：</code></pre><p><img src="/2019/04/24/kettle4/5.png" alt="info"><br>    等同于以下转换：<br><img src="/2019/04/24/kettle4/6.png" alt="info"><br>    分发和合并记录行的过程中有一些可衡量的开销，通常情况下，<br><strong>最好让连续的步骤复制数目保持一致，用来减少这个开销。</strong></p><h3 id="二-多线程的后果"><a href="#二-多线程的后果" class="headerlink" title="二.多线程的后果"></a>二.多线程的后果</h3><pre><code>转换的多线程可能造成的后果，以及如何处理。</code></pre><h4 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h4><pre><code>如果再转换执行的过程中为每个线程创建单一链接，那么每个步骤复制都打开它们自己单独的事务或者事务集。这会导致一个潜在后果，就是使用同一个数据库资源场景下（比如一张表），会发生条件竞争。一个典型场景是当往一个关系数据表里写入数据并在随后步骤读回时，不能确保第一个步骤写入数据可见于其他执行读操作的步骤。</code></pre><p><strong>解决方法：</strong><br>    可以强制所有步骤使用单一数据库连接，启用转换设置对话框中的“Make the transformation database transcational”，这样会降低转换性能。</p><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><pre><code>转换中的步骤没有特定执行顺序，如果需要按顺序执行，可以创建一个作业。也可以用以下几个技巧：</code></pre><p><strong>Blocking步骤</strong><br>    Blocking步骤在默认配置下是简单的吃掉所有记录行后，才将最后一条记录行传递给下一个步骤。</p><h4 id="作业中的并行执行"><a href="#作业中的并行执行" class="headerlink" title="作业中的并行执行"></a>作业中的并行执行</h4><pre><code>可以在作业里并行执行作业项，如下所示：</code></pre><p><img src="/2019/04/24/kettle4/7.png" alt="info"></p><h3 id="三-用Carte作为子服务器"><a href="#三-用Carte作为子服务器" class="headerlink" title="三.用Carte作为子服务器"></a>三.用Carte作为子服务器</h3><pre><code>子服务器是在远程服务器上执行转换和作业的一个组成模块。Carte是一个轻量级的服务器进程，可以远程监控和开启转换集群的能力。   子服务器是集群的最小组成模块。它是一个小型的HTTP服务器，用来接收远程客户端的命令，这些命令控制了自服务器上的作业和转换的部署、管理和监控。启动一个子服务器：sh carte.sh server1 8181</code></pre><h4 id="定义子服务器"><a href="#定义子服务器" class="headerlink" title="定义子服务器"></a>定义子服务器</h4><pre><code>如图所示：</code></pre><p><img src="/2019/04/24/kettle4/8.png" alt="info"></p><h3 id="四-集群转换"><a href="#四-集群转换" class="headerlink" title="四.集群转换"></a>四.集群转换</h3><pre><code>集群技术可以用来水平扩展转换，使得他们能够同时运行在多台服务器上。它将转换的工作量均分到不同的服务器上。这部分将介绍如何配置和执行一个转换，让其运行在多台机器上。   一个集群schema由一台主服务器，和一起子服务器组成，主服务器作为一个集群的控制器。一个集群schema也包含元数据，记录主服务器和子服务器之间怎样来回传递数据。在Carte服务器之间传递数据是通过TCP/IP套接字。注意：要想使得一台子服务器变成主服务器，可以简单地在子服务器的复选框里勾选“is the master”。</code></pre><h4 id="定义一个集群schema"><a href="#定义一个集群schema" class="headerlink" title="定义一个集群schema"></a>定义一个集群schema</h4><pre><code>在定义一个集群schema之前，需要定义一些子服务器。新建集群schema如下图所示：</code></pre><p><img src="/2019/04/24/kettle4/9.png" alt="info"></p><ul><li>端口：TCP/IP socket端口用来传输数据从一台子服务器到另一台。</li><li>Sockets缓存大小：用来缓解子服务器之间通信。</li><li>Dynamic Cluster：启用时，会使Kettle在主服务器上动态搜索，决定schema的子服务器的列表。</li></ul><h4 id="设计集群转换"><a href="#设计集群转换" class="headerlink" title="设计集群转换"></a>设计集群转换</h4><pre><code>要设计一个集群转换，得先建立一个标准的转换，然后将其变为集群类型的。创建一个集群schema，选择想要在其上运行的步骤，右击这个步骤，选择想要执行这个步骤的集群。当执行这个转换，所有被定义成集群运行（有C*1）的步骤都将运行在这个子服务器上，而没有标识的步骤运行在主服务器上。</code></pre><h4 id="Kettle集群的缺点"><a href="#Kettle集群的缺点" class="headerlink" title="Kettle集群的缺点"></a>Kettle集群的缺点</h4><pre><code>Kettle集群能在部分服务器宕机的情况下继续使用。在Kettle中集群是由一个主Carte服务器和多个从Carte服务器组成。在执行转换时，主服务器负责分发跟踪任务和收集结果汇总，从服务器负责具体的转换执行。在Kettle中，如果主服务器也宕机的话并不存在服务器重新选举的功能（类似redis、zookeeper），一旦主服务器宕机，则Kettle集群就不能使用了。</code></pre><h3 id="五-分区"><a href="#五-分区" class="headerlink" title="五.分区"></a>五.分区</h3><h4 id="定义一个分区"><a href="#定义一个分区" class="headerlink" title="定义一个分区"></a>定义一个分区</h4><p><strong>Kettle中的分区是指kettle可以根据一个分区规则引导数据记录行到某一个步骤复制（步骤的多线程）的能力。</strong><br>    在kettle中，一组给定的分区集叫做分区schema，规则本身叫做分区方法。分区schema要么包含一命名的分区列表，要么简单的包含数个分区。分区方法不是分区schema的一部分。<br>       如下图所示为新建一个分区：<br><img src="/2019/04/24/kettle4/10.png" alt="info"><br>    一旦这个分区schema定义，在转换李，可以根据一个分区方法应用它到一个步骤。当在这个步骤菜单上选择分区选项时，会弹出一个对话框让你选择使用哪个分区方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;Kettle的转换和作业可以在垂直和水平方面进行扩展。
垂直扩展是尽可能利用单台服务器上的多CPU核数。水平扩展是使用多台机器资源，使他们并行计算。
下面先谈谈转换内部的并行机制。&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;一-多线程&quot;&gt;&lt;a href=&quot;#一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kettle 集群开发</title>
    <link href="http://yoursite.com/2019/04/24/kettle3/"/>
    <id>http://yoursite.com/2019/04/24/kettle3/</id>
    <published>2019-04-24T02:06:05.000Z</published>
    <updated>2019-08-28T09:22:29.880Z</updated>
    
    <content type="html"><![CDATA[<h3 id="trans集群开发"><a href="#trans集群开发" class="headerlink" title="trans集群开发"></a>trans集群开发</h3><p>新建trans，在主对象树子服务器中右键，新建，填写服务器连接信息。<br><img src="/2019/04/24/kettle3/1.png" alt="info"></p><p>注意：该部分配置信息需要和carte-config-m、aster，-8080.xml配置信息一致，由于是主服务器，需要勾选最后一栏。</p><p>然后填写两个子服务器信息，需要和-8081.xml和-8082.xml中的信息一致。</p><ul><li>注意<br>  服务器的名称一定要与pwd文件夹下面的配置文件<name>属性所对应的值是一致的。所新建的子服务器一定要在pwd文件夹下面要有对应的配置文件才可以。<br><img src="/2019/04/24/kettle3/2.png" alt="info"><br><img src="/2019/04/24/kettle3/3.png" alt="info"></name></li></ul><p>在主对象树中的kettle集群Schemas，右键，新建，选择子服务器，将刚刚配置好的三台子服务器添加到Schemas中。</p><p><img src="/2019/04/24/kettle3/5.png" alt="info"></p><p>然后点击确定。</p><p>接下来对需要进行集群的节点右键选择集群</p><p>选择已经设置好的集群<br><img src="/2019/04/24/kettle3/6.jpg" alt="info"></p><p>使用集群启动，需要先进行启动配置，选择remote中的Clustered。<br><img src="/2019/04/24/kettle3/8.png" alt="info"><br>然后运行的时候选择我们刚刚配置的集群运行模式即可。从日志中我们可以看到主服务器只是做任务转发和合并的工作。如果不是集群的步骤，则指定一个从服务器执行；如果是集群步骤则将输入的流分均分给从服务器执行。</p><h3 id="job集群开发"><a href="#job集群开发" class="headerlink" title="job集群开发"></a>job集群开发</h3><p>job的集群开发，并不是和trans一样，job的集群开主要是将trans分配到不同的子服务器中执行。<br>首先配置子服务器的方法和trans一样，如下图：<br><img src="/2019/04/24/kettle3/9.png" alt="info"></p><p>配置一个 run configurations ，配置job运行的服务器。<br><img src="/2019/04/24/kettle3/10.png" alt="info"></p><p>在转换步骤选择刚刚配置的启动配置<br><img src="/2019/04/24/kettle3/11.png" alt="info"></p><p>这里就完成了job的集群设置，可以让job在对应的服务器上运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;trans集群开发&quot;&gt;&lt;a href=&quot;#trans集群开发&quot; class=&quot;headerlink&quot; title=&quot;trans集群开发&quot;&gt;&lt;/a&gt;trans集群开发&lt;/h3&gt;&lt;p&gt;新建trans，在主对象树子服务器中右键，新建，填写服务器连接信息。&lt;br&gt;&lt;img
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kettle分布式集群搭建</title>
    <link href="http://yoursite.com/2019/04/23/kettle2/"/>
    <id>http://yoursite.com/2019/04/23/kettle2/</id>
    <published>2019-04-23T10:55:27.000Z</published>
    <updated>2019-08-28T09:22:29.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集群环境设置"><a href="#集群环境设置" class="headerlink" title="集群环境设置"></a>集群环境设置</h2><h3 id="ip地址映射（在主机和从机中均做此映射）"><a href="#ip地址映射（在主机和从机中均做此映射）" class="headerlink" title="ip地址映射（在主机和从机中均做此映射）"></a>ip地址映射（在主机和从机中均做此映射）</h3><p><img src="/2019/04/23/kettle2/kitlle1.jpg" alt="info"></p><h3 id="kettle-配置"><a href="#kettle-配置" class="headerlink" title="kettle 配置"></a>kettle 配置</h3><p>之后我们进入之前安装好的kettle目录下，找到配置文件 carte-config-master-8080.xml。<br><img src="/2019/04/23/kettle2/kettle1.png" alt="info"><br>注意红框部分的配置<br><img src="/2019/04/23/kettle2/kettle2.jpg" alt="info"></p><p>找到 carte-config-8081.xml 文件做如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;masters&gt;</span><br><span class="line"></span><br><span class="line">  &lt;slaveserver&gt;</span><br><span class="line">    &lt;name&gt;master1&lt;/name&gt;</span><br><span class="line">    &lt;hostname&gt;192.168.213.128&lt;/hostname&gt;</span><br><span class="line">    &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">    &lt;username&gt;cluster&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;cluster&lt;/password&gt;</span><br><span class="line">    &lt;master&gt;Y&lt;/master&gt;</span><br><span class="line">  &lt;/slaveserver&gt;</span><br><span class="line"></span><br><span class="line">&lt;/masters&gt;</span><br><span class="line"></span><br><span class="line">&lt;report_to_masters&gt;Y&lt;/report_to_masters&gt;</span><br><span class="line"></span><br><span class="line">&lt;slaveserver&gt;</span><br><span class="line">  &lt;name&gt;slave1-8081&lt;/name&gt;</span><br><span class="line">  &lt;hostname&gt;192.168.213.129&lt;/hostname&gt;</span><br><span class="line">  &lt;port&gt;8081&lt;/port&gt;</span><br><span class="line">  &lt;username&gt;cluster&lt;/username&gt;</span><br><span class="line">  &lt;password&gt;cluster&lt;/password&gt;</span><br><span class="line">  &lt;master&gt;N&lt;/master&gt;</span><br><span class="line">&lt;/slaveserver&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找到 carte-config-8082.xml 文件做如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;masters&gt;</span><br><span class="line"></span><br><span class="line">  &lt;slaveserver&gt;</span><br><span class="line">    &lt;name&gt;master1&lt;/name&gt;</span><br><span class="line">    &lt;hostname&gt;192.168.213.128&lt;/hostname&gt;</span><br><span class="line">    &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">    &lt;username&gt;cluster&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;cluster&lt;/password&gt;</span><br><span class="line">    &lt;master&gt;Y&lt;/master&gt;</span><br><span class="line">  &lt;/slaveserver&gt;</span><br><span class="line"></span><br><span class="line">&lt;/masters&gt;</span><br><span class="line"></span><br><span class="line">&lt;report_to_masters&gt;Y&lt;/report_to_masters&gt;</span><br><span class="line"></span><br><span class="line">&lt;slaveserver&gt;</span><br><span class="line">  &lt;name&gt;slave2-8082&lt;/name&gt;</span><br><span class="line">  &lt;hostname&gt;192.168.213.127&lt;/hostname&gt;</span><br><span class="line">  &lt;port&gt;8082&lt;/port&gt;</span><br><span class="line">  &lt;username&gt;cluster&lt;/username&gt;</span><br><span class="line">  &lt;password&gt;cluster&lt;/password&gt;</span><br><span class="line">  &lt;master&gt;N&lt;/master&gt;</span><br><span class="line">&lt;/slaveserver&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们因为是配置3节点集群，所以就配置3个就好了，同样的配置我们需要在另外两个服务器上配置。</p><p>在主节点上启动服务<br><img src="/2019/04/23/kettle2/kettle3.png" alt="info"><br>启动成功后会出现如下结果：<br><img src="/2019/04/23/kettle2/kettle4.png" alt="info"></p><p>在浏览器打开<a href="http://192.168.213.128:8080/" target="_blank" rel="noopener">http://192.168.213.128:8080/</a> 地址，其中账号密码由于没有配置，所以都是默认的cluster<br><img src="/2019/04/23/kettle2/kettle5.jpg" alt="info"><br>可以查看状态master 是否启动成功。</p><p>同样在其他从节点也需要启动服务<br><img src="/2019/04/23/kettle2/kettle6.png" alt="info"><br>在浏览器打开<a href="http://192.168.213.129:8081/" target="_blank" rel="noopener">http://192.168.213.129:8081/</a> 地址，可以查看状态server1 是否启动成功<br><img src="/2019/04/23/kettle2/kettle7.jpg" alt="info"><br>在浏览器打开<a href="http://192.168.213.127:8082/" target="_blank" rel="noopener">http://192.168.213.127:8082/</a> 地址，可以查看状态server2 是否启动成功</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集群环境设置&quot;&gt;&lt;a href=&quot;#集群环境设置&quot; class=&quot;headerlink&quot; title=&quot;集群环境设置&quot;&gt;&lt;/a&gt;集群环境设置&lt;/h2&gt;&lt;h3 id=&quot;ip地址映射（在主机和从机中均做此映射）&quot;&gt;&lt;a href=&quot;#ip地址映射（在主机和从机中均做此
      
    
    </summary>
    
    
  </entry>
  
</feed>
